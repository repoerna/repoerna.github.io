<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Docker Tutorial — Complete Beginner’s Guide | purnasatria</title>
<meta name="keywords" content="golang, docker">
<meta name="description" content="Prelude This post will give a basic tutorial on how to using Docker. The topics that will be explained are:
What is Docker
Docker Architecture
Start using Docker (Guide to using basic commands)
Create Image using Dockerfile
Handle Image using Environment Variable
Integrate Container Networking
Manage Data in Docker
Docker Compose
Docker Tools
Docker Cheat-sheet
This post will be pretty long, and I hope you will enjoy it, and feel free to give feedback to help me improve this tutorial.">
<meta name="author" content="Purna Satria Nugraha">
<link rel="canonical" href="https://medium.com/easyread/docker-tutorial-complete-beginners-guide-8b7dd2362c35">
<link crossorigin="anonymous" href="/assets/css/stylesheet.101ee3f260ff9d4e195097b9bc9d34c08651d1a81351cbbb6a8c4ee687cf5652.css" integrity="sha256-EB7j8mD/nU4ZUJe5vJ00wIZR0agTUcu7aoxO5ofPVlI=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://repoerna.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://repoerna.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://repoerna.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://repoerna.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://repoerna.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Docker Tutorial — Complete Beginner’s Guide" />
<meta property="og:description" content="Prelude This post will give a basic tutorial on how to using Docker. The topics that will be explained are:
What is Docker
Docker Architecture
Start using Docker (Guide to using basic commands)
Create Image using Dockerfile
Handle Image using Environment Variable
Integrate Container Networking
Manage Data in Docker
Docker Compose
Docker Tools
Docker Cheat-sheet
This post will be pretty long, and I hope you will enjoy it, and feel free to give feedback to help me improve this tutorial." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://repoerna.github.io/posts/docker-tutorial-complete-beginners-guide/" />
<meta property="og:image" content="https://repoerna.github.io/posts/docker-tutorial-complete-beginners-guide/posts/docker-tutorial-complete-beginners-guide/assets/0%2AIIpt0_gNmTjSNFgo" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-20T05:13:53+00:00" />
<meta property="article:modified_time" content="2021-06-20T05:13:53+00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://repoerna.github.io/posts/docker-tutorial-complete-beginners-guide/posts/docker-tutorial-complete-beginners-guide/assets/0%2AIIpt0_gNmTjSNFgo" />
<meta name="twitter:title" content="Docker Tutorial — Complete Beginner’s Guide"/>
<meta name="twitter:description" content="Prelude This post will give a basic tutorial on how to using Docker. The topics that will be explained are:
What is Docker
Docker Architecture
Start using Docker (Guide to using basic commands)
Create Image using Dockerfile
Handle Image using Environment Variable
Integrate Container Networking
Manage Data in Docker
Docker Compose
Docker Tools
Docker Cheat-sheet
This post will be pretty long, and I hope you will enjoy it, and feel free to give feedback to help me improve this tutorial."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://repoerna.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Docker Tutorial — Complete Beginner’s Guide",
      "item": "https://repoerna.github.io/posts/docker-tutorial-complete-beginners-guide/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker Tutorial — Complete Beginner’s Guide",
  "name": "Docker Tutorial — Complete Beginner’s Guide",
  "description": "Prelude This post will give a basic tutorial on how to using Docker. The topics that will be explained are:\nWhat is Docker\nDocker Architecture\nStart using Docker (Guide to using basic commands)\nCreate Image using Dockerfile\nHandle Image using Environment Variable\nIntegrate Container Networking\nManage Data in Docker\nDocker Compose\nDocker Tools\nDocker Cheat-sheet\nThis post will be pretty long, and I hope you will enjoy it, and feel free to give feedback to help me improve this tutorial.",
  "keywords": [
    "golang", "docker"
  ],
  "articleBody": "Prelude This post will give a basic tutorial on how to using Docker. The topics that will be explained are:\nWhat is Docker\nDocker Architecture\nStart using Docker (Guide to using basic commands)\nCreate Image using Dockerfile\nHandle Image using Environment Variable\nIntegrate Container Networking\nManage Data in Docker\nDocker Compose\nDocker Tools\nDocker Cheat-sheet\nThis post will be pretty long, and I hope you will enjoy it, and feel free to give feedback to help me improve this tutorial.\nThanks, and enjoy it!\nWhat Is Docker? Docker is a configuration management tool that is used to automate the deployment of software in lightweight containers. These containers help applications to work efficiently in different environments. By using Docker, developers can quickly build, pack, ship, and run applications as lightweight, portable, self-sufficient containers and running virtually anywhere.¹ Containers allow developers to package an application with its dependencies and deploy it as a single unit. By providing prebuilt and self-sustaining application containers, developers can focus on the application code and use it without worrying about the underlying operating system or deployment system.²\nDocker Architecture The core concepts of Docker are images and containers. A Docker image contains everything that is needed to run your software: the code, a runtime (for example, Java Virtual Machine (JVM), drivers, tools, scripts, libraries, deployments, and more. A Docker container is a running instance of a Docker image. However, unlike in traditional virtualization with a type 1 or type 2 hypervisor, a Docker container runs on the host operating system’s kernel. Within a Docker Image, there is no separate operating system, as illustrated below.³\nDocker Architecture\nEvery Docker container has its own file system, network stack (and therefore its own IP address), process space, and defined resource limitations for CPU and memory. Since a Docker container does not have to boot an operating system, it starts up instantly. Docker is about isolation, i.e., separating the resources of a host operating system, as opposed to virtualization, i.e., providing a guest operating system on top of the host operating system.\nImage Image is a read-only file with a bunch of instructions. When these instructions are executed, it creates a Docker container. We can say that an Image is a template to create a container.\nContainer A container is a software package that has all the dependencies required to run an application. When running a container, it uses an isolated filesystem.\nContainer Registry Docker Container Registry is where we put Docker Image remotely before deploying it to the server. In another way, it is a standard way to store and distribute Docker images. It also helps improve access control and security of docker images stored in its repository. While managing the distribution of Images, it can also integrate with application development workflow. Developers can set up their own Container Registry because it is an open-source-based repository under the permissive Apache license. You can also use a hosted Container Service such as Docker Hub or Azure Container Registry, etc.\nInstalling a Docker I won’t cover how to install Docker. There are many tutorials on how to install Docker into your machine. For me, I prefer using the official document. You can see the instruction here.\nStart Using Docker After you install the Docker, let’s get into it!\nPull Image from Registry Check the image on our local\n$ docker images Image list\nif you newly install Docker, you won’t see anything on the list. You will just see the header result, REPOSITORY, TAG, IMAGE ID, CREATED, **SIZE**.\nPull the image\nTo pull an image you can use the command:\n$ docker pull or for a specific image version\n$ docker pull : For this example, we will use MongoDB image. You can check it here. If you open the link, you can see on the right, there is a command that tells you how to pull the image.\nDocker hub\nOn the Tags menu, you can see the available version of the image\nDocker hub tags menu\nCopy the image pull command, and run it on your terminal. You will see that the image is being pulled from the registry to our local machine.\nPulling image\nIf we do not specify the tag name, it will automatically pull the latest image on the registry. After Image pulling is finished, we can recheck the images list, you will see mongo on the list\nCreate Container Check running container.\nTo check the running container, you can use\n$ docker container ls It will show only the** **running container, but if you have some container that stopped, it won’t show on the list. To see all containers that we have, we can use\n$ docker container ls --all You can use --all or **-a**. It will show all the containers you have on your local machine. You can see on the image there are some containers running, and some containers stopped.\nYou can see on the image there are some containers running, and some containers stopped.\nCreating container\nThere are many ways to create a container. These commands are:\n$ docker container create to create a container with a specific image tag\n$ docker container create : to create a container with a predefined name, we can use --name argument on our command\n$ docker container create --name : For the example, let’s create a container for our pulled MongoDB image,\n$ docker container create --name test-mongo mongo let’s check it using our container,\nYou can see that there is no test-mongo container. This happens because using the container create command just creates the container and not started it. You can try usingdocker contaner ls -a command to see the container.\nYou can also create multiple containers from the same image with one condition; the container name must be different because the container name is unique. If you create a container without specifying the name, Docker will generate a random name for the container.\nStart Container After we create the container, we can run it using the command\n$ docker container start After we run the command, let’s check our container list,\nAs you can see, our test-mongo is already up and running. In our case, you can see. In our case, you can see PORTS section of test-mongo container, we can access the container by using port 27017.\nLet’s try connecting to MongoDB. You can use a DB client that supports MongoDB connections like Robo3T, but I’m using Datagrip.\nSo, we can’t connect to our MongoDB. Why is this happening? Well, this is because PORTS the info that we see before is port on the container. The container’s behavior is that it will create an isolate the system, which means that we can’t access the system without exposing the port, so it can’t access the outside of the container.\nOpen Port So, how can we expose the container’s port? To achieve that, we should consider passing an argument -p or --port when we create the container, so the command will look like this\n$ docker container create --name -p : : Let’s try creating a new container\nI will explain the command.\ncontainer-port i is a predefined port that already assigns when building the Image. If we were using the Image that we get from the docker registry, we could see the documentation of the Image for ports information. In this case, MongoDB using port 27017.\nAnd in the external-port, I use port 8011. It means, when I’m using port 8011 outside the container (or on my local machine), every request that comes through the port 8011 will be forwarded to port 27017 inside the container.\nTry to start the new container, and with this, we can access MongoDB.\nRemove Container To remove the container we use the command\n$ docker container rm Let’s try to delete test-mongo container\nAn error will occur. This happens because Docker wants that we to stop the container before we remove it. There is two way to handle this,\nStop the container using $ docker container stop and then run the container remove command again\nForce delete the container by using an argument --force $ docker container rm --force Please ensure that you know what you are doing when using this command.\nFor this example, I will use option 2,\nYou can try to recheck the container list to ensure the container is already removed.\nRemove Image Same with removing the container, we can’t remove an image before all container that uses that Image is removed. To remove an image, you can use the command\n$ docker image remove : Let’s stop and remove the container, and then remove the mongo image.\nDocker Logs We can see docker logs to help us debug our application inside the container. To do that, we can use the command\n$ docker logs You can try to create some containers and check the container’s logs. This is an example of my Postgres container.\nGetting through inside the container Even though the container is isolated from the outside of the container, Docker has some commands that we can use to pass a command inside our container. We can use the command\n$ docker exec you can see more about docker exec here\nI will demonstrate using my postgre named dev-postgresto get into Postgres client inside the container.\nYou can see that I am running a command to show the database list inside the container -it means interactive (Keep STDIN open) and tty (Allocate a pseudo-TTY).\nCreate Image with Dockerfile We already use Docker with the Image from the container registry, but how if we want to create an Image? Here comes the Dockerfile. Dockerfile is a simple text file that consists of instructions to build Docker images. Dockerfile consists of commands that guide you on how to build a specific Docker image.\nFor example, we need to prepare some application code to demonstrate how to build an application image. We will create 2 files, the application code, and the Dockerfile. For the application code, I will make a simple HTTP app using Go. You don’t need to have Go runtime on your computer because we will have our app inside the container then have Go runtime in it.\nPrepare an app package main import ( \"fmt\" \"net/http\" ) func main() { // * Handle Route \"/\" http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"Hello Docker!\") }) http.ListenAndServe(\":8000\", nil) } Create a Dockerfile # BUILD IMAGE FROM EXISTING IMAGE # Line with '#' will not executed # 1. Call the image # FROM : # for the base we will use golang image version 1.15 FROM golang:1.15 # 2. Copy file that needed in this image # COPY # we will put file main.go in /app/main.go inside the container COPY main.go /app/main.go # 3. Telling the image how to run the app # CMD [] CMD [\"go\", \"run\", \"/app/main.go\"] # same with \"go run /app/main.go\" Build Image we can use 3 way to build an image:\nsimple way docker build \u0026lt;path-to-dockerfile\u0026gt;\nadd a name in our image docker build --tag \u0026lt;app name\u0026gt; \u0026lt;path-to-dockerfile\u0026gt;\nadd name and version number docker build --tag \u0026lt;app name\u0026gt;:\u0026lt;version number\u0026gt; \u0026lt;path-to-dockerfile\u0026gt;\n$ docker build --tag app-golang:1.0 . building an image using Dockerfile can be done in various ways, depends on your needs, and many Dockerfile syntaxes are often used when creating an image, such as:\nENTRYPOINT\nRUN\nWORKDIR\nENV\nread this docker documentation, get to know all the syntax, and see the best practice of using it.\nCreate our app container Let’s try to create a container for our app and run it. Then we can check our app using the browser.\nUpload Image to Registry Preparation\nLogin to your account at https://hub.docker.com/ Create New repository for the image Push image\nWe will use the docker command to push the image, docker push \u0026lt;repository name\u0026gt;:\u0026lt;tag\u0026gt;\nIf we try to insert the command, we will get an error: An image does not **exist locally ...**\nThis will happen because we create an image with a name that is different from our repository name. Let’s check the Image in our local, using:\n$ docker images our local image is named app-golang but the docker registry wants repoerna/example-go-app.\nTo resolve this, we need to do create the image with different names by using\n$ docker tag : : check docker images in our local, we will see the new image created,\nafter that, we can push to the repository, by using the same command we used before\nOops! We still get an error, our request to push is denied. It is because, our local docker didn’t know, where to push the image.\nWe need to login, by using\n$ docker login input your account credential for the docker hub\nafter we logged in, let’s try to push again\nAlright! We success push our local image to the remote repository, lets check in the docker hub\n​ For details about the docker repository, you can read the documentation\nHandle Image with Environment Variable An environment variable is a dynamic-named value that can affect the way running processes will behave on a computer. They are part of the environment in which a process runs. — Wikipedia\nAn environment variable is rarely used directly. It is usually used by a program to configure itself. In software development, some configurations for the program/ application are set by using an environment variable. If we want our program to change some configuration, we can achieve this by changing the environment variable without changing the code.\nin Linux or macOS, you can see your OS environment variable using the command\n$ printenv if you using Windows, you can access the environment variable by open Control Panel \u003e Advanced system settings \u003e Environment Variable. You will see the Environment Variable window.\nIf we want to dockerize our program that needs an environment variable, we should add some commands before running the container. To give you an example, let’s update our program to handle some environment variables. We will add a new route to manage the environment variable.\npackage main import ( \"fmt\" \"net/http\" \"os\" ) func main() { package main import ( \"fmt\" \"net/http\" \"os\" ) func main() { // * this will set env variable MYNAME // os.Setenv(\"MYNAME\", \"REPOERNA\") // * get env variable MYNAME appPort := os.Getenv(\"APP_PORT\") port := fmt.Sprintf(\":%s\", appPort) myName := os.Getenv(\"MYNAME\") txt := fmt.Sprintf(\"Hello, %s\", myName) // \u003c-- env var MYNAME will be used in this line // * Handle Route \"/\" http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"Hello Docker!\") }) // * Handle route \"/myname\" http.HandleFunc(\"/myname\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, txt) }) http.ListenAndServe(port, nil) // \u003c-- env var APP_PORT will be used in this line } Remember, in our program, we need two environment variables, APP_PORT and MYNAME. After updating our program, rebuild it without changing the Dockerfile.\n$ docker build --tag app-golang:1.0 . and then create a container using the image, and add -eto add an environment variable\n$ docker container create --name golang-test-env -p 8080:8080 -e APP_PORT=8080 -e MYNAME=REPOERNA app-golang:1.0 after the container is created, let’s inspect the environment variable in it by using the command\n$ docker container inspect golang-test-env In the list, you will see in Env with APP_PORT and MYNAME. The value is the same as the command that we type before. For PATH, GOLANG_VERSION, GOPATH are automatically added, because we use golang in our Dockerfile.\nSo let’s run the container, to check our program is working\n$ docker container start golang-test-env if no error occurred, open in browser localhost:8080/myname, it will show the MYNAME environment variable value.\nNote: when using a Dockerfile to create an image, you can specify the environment variable inside your Dockerfile. Please see the official documentation on how to implement that. Integrate Container Networking In this section, we will talk about connecting containers to another container. Let say we have a web server that needs to communicate with Postgres for its database and Redis for its caching or session storage.\nSo, we will prepare 3 containers, one for the app, one for Postgres, and one for Redis. Before that, let’s prepare our app. We will be using our previous app and add some code to connect with Postgres and Redis.\nUpdate our app main.go\nWe will add some database connections to our app.\nPackage main import ( \"database/sql\" \"fmt\" \"net/http\" \"os\" \"github.com/go-redis/redis\" _ \"github.com/lib/pq\" ) func main() { dbHost := os.Getenv(\"DB_HOST\") dbPort := 5432 dbUser := \"postgres\" dbPass := \"Secure123\" dbName := \"docker-demo\" redisHost := os.Getenv(\"REDIS_HOST\") redisAddr := fmt.Sprintf(\"%s:6379\", redisHost) redisPass := \"\" //no password set redisDB := 0 //default db // * setup postgre connection dsn := fmt.Sprintf(\"host=%s port=%d user=%s \"+ \"password=%s dbname=%s sslmode=disable\", dbHost, dbPort, dbUser, dbPass, dbName) db, err := sql.Open( \"postgres\", dsn, ) if err != nil { fmt.Println(err) } // * Ping for test the connection if err = db.Ping(); err != nil { fmt.Println(err) } else { fmt.Println(\"DB Postgres Connected !\") } // * setup redis connection rdb := redis.NewClient(\u0026redis.Options{ Addr: redisAddr, Password: redisPass, DB: redisDB, }) // * Ping for test the connection pong, err := rdb.Ping().Result() if err != nil { fmt.Println(err) } else { fmt.Println(pong) fmt.Println(\"Redis Connected !\") } // * get env variable MYshNAME appPort := os.Getenv(\"APP_PORT\") // handle for default port if appPort == \"\" { appPort = \"8080\" } port := fmt.Sprintf(\":%s\", appPort) // myName := os.Getenv(\"MYNAME\") // txt := fmt.Sprintf(\"Hello, %s\", myName) // * Handle Route \"/\" http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"Hello Docker!\") }) // * Handle route \"/myname\" // http.HandleFunc(\"/myname\", func(w http.ResponseWriter, r *http.Request) { // fmt.Fprintf(w, txt) // }) http.ListenAndServe(port, nil) } For Postgres and Redis hostname, we will use an environment variable, and because we are using Redis, we need to use modules in our go app. Therefore we need to update our Dockerfile to handle go modules.\nDockerfile\nFROM golang:1.15 ENV GO111MODULE=on WORKDIR /app RUN go mod init COPY . . RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build EXPOSE 8080 CMD [\"go\", \"run\", \"/app/main.go\"] After the app is ready, we will continue preparing the container, and don’t forget to clean up the previous container\nCreate Container Rebuild our golang app image $ docker build — tag app-golang:1.0 . Create golang app container $ docker container create — name golang-docker -e REDIS_HOST=localhost -e DB_HOST=localhost -p 8080:8080 app-golang:1.0 Create Postgres container $ docker container create --name postgres-docker -p 5432:5432 -e POSTGRES_DB=docker-demo -e POSTGRES_PASSWORD=mysecretpassword postgres Create Redis container $ docker container create --name redis-docker -p 6379:6379 redis let’s see our created containers\nStart Containers start all 3 containers\n$ docker container start redis-docker postgres-docker golang-docker check our app container\n$ docker container logs golang-docker As I expected, an error will happen because we were trying to connect to localhost. We can’t connect to localhost because Redis and Postgres are in a different containers. We need to use the container name as the hostname. So, let’s delete golang-dockercontainer and re-create it.\n$ docker container create --name golang-docker -e REDIS_HOST=redis-docker -e DB_HOST=postgres-docker -p 8080:8080 app-golang:1.0 Start the container, and check logs again.\nWe still can’t connect to Redis and Postgres. What happens here? As you can see, there is an error occur in our app. This will occurred because our program still can’t find Redis and Postgres. Before using localhost or 127.0.0.1 as the host, localhost refers to the hostname in the current computer or system.\nAs you know, when creating a container, the system inside it will be isolated from another container. Even if we want the container to connect to our laptop or computer, we need to expose the container port and mapping it to our computer port. But, after we changed the hostname to the container name, errors still occurred. So how to make containers communicate with each other?\nSetup Container Network To achieve that, we need to use docker network, which will help us connecting containers\n$ docker network --help Create docker network $ docker network create example-network we can check our created network by using\n$ docker network ls Set container network $ docker network connect example-network golang-docker $ docker network connect example-network redis-docker $ docker network connect example-network postgres-docker After we connect the containers to the network, let’s inspect our container\n$ docker container inspect golang-docker You can see in “Networks”, there is example-network, that we created before.\nLet’s restart our golang-app container, and check the logs\n$ docker container restart golang-docker Finally, it’s connected! Congratulations to us!\nManage Data in Docker When creating an application, it is best to make it stateless. It means no data are saved or the data stored somewhere else. However, some applications need to be stateful, for example, databases. How do we run a stateful application? How can we save the data so when we delete a container, the data will still remain?\nActually, you can read the documentation about that here\nThere are many ways to manage data in Docker. Usually, I will use bind mounts, but we will try to use volume this time.\nIn this example, we will try to create a MongoDB container. To manage data, first, we must know where is application save its data. If you use mongo image from docker hub, we can see in the description at subtitle Where to store data, from there we can see where is mongo data reside, it’s in /data/db.\nSo, let’s start…\nPull image $ docker pull mongo Create new volume $ docker create volume mongo-test The volume will be used in our container. This is where data will be saved. You can check where is volume stored in your computer by using the command:\n$ docker volume inspect Create container $ docker container create --name mongo-docker -v mongo-test:/data/db -p 27017:27017 In this command we use -v \u0026lt;docker_volume\u0026gt;:\u0026lt;data location in application\u0026gt; to create volume binding between docker and our computer.\nStart container $ docker container start mongo-docker Open mongo DB using mongo client, here I’m using Studio 3T By default, there are 3 DB like above in the newly created MongoDB. Let’s create a new DB and add new data in there\nCreate a new DB and insert some data Here, I already create new DB named test_db, a collection name test_collection, and inside that collection there 1 document\nStop and delete the container $ docker container stop mongo-docker $ docker container rm mongo-docker Create and start the container again using the same command in steps 3 and 4\nCheck DB again using Mongo client\nYou will see, that your data is still there. Congratulation!\nThat is one method of how to manage data in docker, there is still many ways to manage data in docker. Please be sure to read the documentation. In there you will know what method to use and how to use it for your needs.\nDocker Compose We already learn to integrate our containers. In the previous example, we use 3 containers, but what if our application or system needs more than that? Doing it manually every step will be a problem, right? So, Docker Compose will help us automate that process.\nBasically, there are 3 steps to use Docker Compose, these steps are:\nDefine your app’s environment with a Dockerfile so it can be reproduced anywhere.\nDefine the services that make up your app in docker-compose.yml to be run together in an isolated environment.\nRun docker-compose up and Compose starts and runs your entire app.\nIn step 1, we already learn how to create Dockerfile so we will focus on step 2, how to create docker-compose.yml file, and step 3, how to run it.\nLet’s create our**docker-compose.yml** ,\nversion: \"3.9\" # optional since v1.27.0 services: db: container_name: postgres-comose image: postgres ports: - 5432:5432 networks: - compose-network environment: - POSTGRES_DB=docker-demo - POSTGRES_PASSWORD=mysecretpassword cache: container_name: redis-compose image: redis ports: - 6379:6379 networks: - compose-network app: container_name: golang-compose # image: app-golang:1.0 build: context: . dockerfile: Dockerfile ports: - 8080:8080 restart: unless-stopped networks: - compose-network depends_on: - db - cache environment: - REDIS_HOST=redis-compose - DB_HOST=postgres-compose - MYNAME=REPOERNA networks: compose-network: name: new-example-network *Note: in the app service environment, we use REDIS_HOST and DB_HOST using Redis and Postgres container name\nOkay, I will explain what we write. At the root of the file, we have:\nversion define Compose release. Each release has different features and parameters that we can use. You can read the compatibility matrix of each version here. If you omit the versionby default, it will use version 1.\nservices defined all services in our system. In our example, before we use Postgres, Redis, and golang app, those 3 services will be defined here.\nnetwork define network will be used, if you haven’t created the network, it will be automatically created, and you can create more than one network here.\nInside services, there is the service name; we have DB, cache, and app. On every service, we will define a parameter that will be used on each service. these parameters are:\ncontainer_name defines name services container.\nimage define an image that will be used for creating the container.\nport define port binding to exposed the port inside a container with the environment outside.\nnetworks define a network that will be used by services.\ndepends_on define other services that needed by app services.\nenvironment define environment variable inside the container.\nIn app service, instead of using an image, we will use build to build the image, below build there is context that define the location of Dockerfle that will be used to build the image and dockerfile to define Dockerfile filename.\nTo run Docker Compose, we need to use some commands, you can check in your terminal by using\n$ docker-compose It will show you a list of commands and a short description of its function. You need to know how to use it properly. There are common commands that I frequently used:\ndocker-compose build It will rebuild the image if you are using build instead of image in your docker-compose.yml, if your services using existing images, there will be an error occurred.\ndocker-compose up -d It will create and start containers, it is best to use-d or daemon mode, to run the process in the background.\ndocker-compose down it will stop and remove containers, networks, images, and volumes. Please beware if you using a database in your services, when you use this command, the data will also be removed.\nSo, let’s run the Docker Compose\nRebuild the image $ docker-compose build this process will be the same with docker build\nStart services $ docker-compose up -d Check our application Our services are up! No error occurred.\nClean Up $ docker-compose down Docker Tools — Kitematic Docker tool is software that you can use to help you manage Docker using GUI. Docker has its own tools called Docker Desktop, but it is only for Windows and macOS. For Linux, I preferred using Kitematic because it also can run on Windows, macOS. It also has more features than Docker Desktop.\nThe features are:\nCreate, delete, start \u0026 stop a container\nView containers logs\nManaging volumes\nAdd environment variables\nCommand-Line Access\nYou can see the details on\nYou can see the details on Kitematic website or docker documentation.\nDocker Cheat Sheet Refrence [1] What Is Dockerfile: Everything You Need to Know\n[2] Docker Containers and Container Cloud Services\n[3] Basic about Docker in the Oracle\n",
  "wordCount" : "4572",
  "inLanguage": "en",
  "image":"https://repoerna.github.io/posts/docker-tutorial-complete-beginners-guide/posts/docker-tutorial-complete-beginners-guide/assets/0%2AIIpt0_gNmTjSNFgo","datePublished": "2021-06-20T05:13:53.885Z",
  "dateModified": "2021-06-20T05:13:53.885Z",
  "author":{
    "@type": "Person",
    "name": "Purna Satria Nugraha"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://repoerna.github.io/posts/docker-tutorial-complete-beginners-guide/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "purnasatria",
    "logo": {
      "@type": "ImageObject",
      "url": "https://repoerna.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://repoerna.github.io" accesskey="h" title="purnasatria (Alt + H)">purnasatria</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div><a>dev</a>
        </div>
        <ul id="menu">
            <li>
                <a href="https://repoerna.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://repoerna.github.io">Home</a>&nbsp;»&nbsp;<a href="https://repoerna.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Docker Tutorial — Complete Beginner’s Guide
    </h1>
    <div class="post-meta"><span title='2021-06-20 05:13:53.885 +0000 UTC'>June 20, 2021</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;Purna Satria Nugraha

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://repoerna.github.io/posts/docker-tutorial-complete-beginners-guide/assets/0%2AIIpt0_gNmTjSNFgo" alt="Photo by Ian Taylor">
        <p><em>Photo by <a href="https://unsplash.com/@carrier_lost?utm_source=medium&amp;utm_medium=referral">Ian Taylor</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></em></p>
</figure>
  <div class="post-content"><h2 id="prelude">Prelude<a hidden class="anchor" aria-hidden="true" href="#prelude">#</a></h2>
<p>This post will give a basic tutorial on how to using Docker. The topics that will be explained are:</p>
<ul>
<li>
<p><strong>What is Docker</strong></p>
</li>
<li>
<p><strong>Docker Architecture</strong></p>
</li>
<li>
<p><strong>Start using Docker (Guide to using basic commands)</strong></p>
</li>
<li>
<p><strong>Create Image using Dockerfile</strong></p>
</li>
<li>
<p><strong>Handle Image using Environment Variable</strong></p>
</li>
<li>
<p><strong>Integrate Container Networking</strong></p>
</li>
<li>
<p><strong>Manage Data in Docker</strong></p>
</li>
<li>
<p><strong>Docker Compose</strong></p>
</li>
<li>
<p><strong>Docker Tools</strong></p>
</li>
<li>
<p><strong>Docker Cheat-sheet</strong></p>
</li>
</ul>
<p>This post will be pretty long, and I hope you will enjoy it, and feel free to give feedback to help me improve this tutorial.</p>
<p>Thanks, and enjoy it!</p>
<h2 id="what-is-docker">What Is Docker?<a hidden class="anchor" aria-hidden="true" href="#what-is-docker">#</a></h2>
<p><strong><a href="https://docs.docker.com/get-started/overview/">Docker</a></strong> is a configuration management tool that is used to automate the deployment of software in lightweight containers. These containers help applications to work efficiently in different environments. By using Docker, developers can quickly build, pack, ship, and run applications as lightweight, portable, self-sufficient containers and running virtually anywhere.¹ Containers allow developers to package an application with its dependencies and deploy it as a single unit. By providing prebuilt and self-sustaining application containers, developers can focus on the application code and use it without worrying about the underlying operating system or deployment system.²</p>
<h2 id="docker-architecture">Docker Architecture<a hidden class="anchor" aria-hidden="true" href="#docker-architecture">#</a></h2>
<p>The core concepts of Docker are images and containers. A Docker image contains everything that is needed to run your software: the code, a runtime (for example, Java Virtual Machine (JVM), drivers, tools, scripts, libraries, deployments, and more.
A Docker container is a running instance of a Docker image. However, unlike in traditional virtualization with a type 1 or type 2 hypervisor, a Docker container runs on the host operating system’s kernel. Within a Docker Image, there is no separate operating system, as illustrated below.³</p>
<p><img loading="lazy" src="./assets/0*pqIVWn0AomBJGm8k.png" alt=" "  />
<!-- raw HTML omitted --><em>Docker Architecture</em></p>
<p>Every Docker container has its own file system, network stack (and therefore its own IP address), process space, and defined resource limitations for CPU and memory. Since a Docker container does not have to boot an operating system, it starts up instantly. Docker is about isolation, i.e., separating the resources of a host operating system, as opposed to virtualization, i.e., providing a guest operating system on top of the host operating system.</p>
<h3 id="image">Image<a hidden class="anchor" aria-hidden="true" href="#image">#</a></h3>
<p>Image is a read-only file with a bunch of instructions. When these instructions are executed, it creates a Docker container. We can say that an Image is a template to create a container.</p>
<h3 id="container">Container<a hidden class="anchor" aria-hidden="true" href="#container">#</a></h3>
<p>A container is a software package that has all the dependencies required to run an application. When running a container, it uses an isolated filesystem.</p>
<h3 id="container-registry">Container Registry<a hidden class="anchor" aria-hidden="true" href="#container-registry">#</a></h3>
<p>Docker Container Registry is where we put Docker Image remotely before deploying it to the server. In another way, it is a standard way to store and distribute Docker images. It also helps improve access control and security of docker images stored in its repository. While managing the distribution of Images, it can also integrate with application development workflow. Developers can set up their own Container Registry because it is an open-source-based repository under the permissive Apache license. You can also use a hosted Container Service such as Docker Hub or Azure Container Registry, etc.</p>
<h2 id="installing-a-docker">Installing a Docker<a hidden class="anchor" aria-hidden="true" href="#installing-a-docker">#</a></h2>
<p>I won’t cover how to install Docker. There are many tutorials on how to install Docker into your machine. For me, I prefer using the official document. You can see the instruction <a href="https://docs.docker.com/engine/install/">here</a>.</p>
<h2 id="start-using-docker">Start Using Docker<a hidden class="anchor" aria-hidden="true" href="#start-using-docker">#</a></h2>
<p>After you install the Docker, let’s get into it!</p>
<h3 id="pull-image-from-registry">Pull Image from Registry<a hidden class="anchor" aria-hidden="true" href="#pull-image-from-registry">#</a></h3>
<p><strong>Check the image on our local</strong></p>
<pre tabindex="0"><code>$ docker images
</code></pre><p><img loading="lazy" src="./assets/0*elSkYT8BS92X6Hma.png" alt=" "  />
<!-- raw HTML omitted --><em>Image list</em></p>
<p>if you newly install Docker, you won’t see anything on the list. You will just see the header result, <strong><code>REPOSITORY</code></strong>, <strong><code>TAG</code></strong>, <strong><code>IMAGE ID</code></strong>, <strong><code>CREATED</code></strong>, **<code>SIZE**.</code></p>
<p><strong>Pull the image</strong></p>
<p>To pull an image you can use the command:</p>
<pre tabindex="0"><code>$ docker pull &lt;image-name&gt;
</code></pre><p>or for a specific image version</p>
<pre tabindex="0"><code>$ docker pull &lt;image-name&gt;:&lt;tag-name&gt;
</code></pre><p>For this example, we will use MongoDB image. You can check it <strong><a href="https://hub.docker.com/_/mongo/">here</a></strong>. If you open the link, you can see on the right, there is a command that tells you how to pull the image.</p>
<p><img loading="lazy" src="./assets/0*Tq5pMziTsl69dtba.png" alt=" "  />
<!-- raw HTML omitted --><em>Docker hub</em></p>
<p>On the <strong><code>Tags</code></strong> menu, you can see the available version of the image</p>
<p><img loading="lazy" src="./assets/0*AfpvC76lztfvh-rp.png" alt=" "  />
<!-- raw HTML omitted --><em>Docker hub tags menu</em></p>
<p>Copy the image pull command, and run it on your terminal. You will see that the image is being pulled from the registry to our local machine.</p>
<p><img loading="lazy" src="./assets/0*Qw-kwpRtACBryYU3.png" alt=" "  />
<!-- raw HTML omitted --><em>Pulling image</em></p>
<p>If we do not specify the tag name, it will automatically pull the latest image on the registry. After Image pulling is finished, we can recheck the images list, you will see mongo on the list</p>
<p><img loading="lazy" src="./assets/0*bpfrqX2aQAIfW8sI.png" alt=" "  />
<!-- raw HTML omitted --></p>
<h3 id="create-container">Create Container<a hidden class="anchor" aria-hidden="true" href="#create-container">#</a></h3>
<p><strong>Check running container.</strong></p>
<p>To check the running container, you can use</p>
<pre tabindex="0"><code>$ docker container ls
</code></pre><p>It will show only the** **running container, but if you have some container that stopped, it won’t show on the list. To see all containers that we have, we can use</p>
<pre tabindex="0"><code>$ docker container ls --all
</code></pre><p>You can use <strong><code>--all</code></strong> or **<code>-a**.</code> It will show all the containers you have on your local machine. You can see on the image there are some containers running, and some containers stopped.</p>
<p><img loading="lazy" src="./assets/0*46ZkpSAWa6BK1k1P.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>You can see on the image there are some containers running, and some containers stopped.</p>
<p><strong>Creating container</strong></p>
<p>There are many ways to create a container. These commands are:</p>
<pre tabindex="0"><code>$ docker container create &lt;image-name&gt;
</code></pre><p>to create a container with a specific image tag</p>
<pre tabindex="0"><code>$ docker container create &lt;image-name&gt;:&lt;tag&gt;
</code></pre><p>to create a container with a predefined name, we can use <strong><code>--name</code></strong> argument on our command</p>
<pre tabindex="0"><code>$ docker container create --name &lt;some-container-name&gt; &lt;image-name&gt;:&lt;tag&gt;
</code></pre><p>For the example, let’s create a container for our pulled MongoDB image,</p>
<pre tabindex="0"><code>$ docker container create --name test-mongo mongo
</code></pre><p><img loading="lazy" src="./assets/0*hdgh4ZekLun_yoBl.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>let’s check it using our container,</p>
<p><img loading="lazy" src="./assets/0*VdoLOTlsac_EpZIA.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>You can see that there is no test-mongo container. This happens because using the container create command just creates the container and not started it. You can try using<code>docker contaner ls -a</code> command to see the container.</p>
<p>You can also create multiple containers from the same image with one condition; the container name must be different because the container name is unique. If you create a container without specifying the name, Docker will generate a random name for the container.</p>
<h3 id="start-container">Start Container<a hidden class="anchor" aria-hidden="true" href="#start-container">#</a></h3>
<p>After we create the container, we can run it using the command</p>
<pre tabindex="0"><code>$ docker container start &lt;container-name&gt;
</code></pre><p><img loading="lazy" src="./assets/0*RTq3BB53jVI1EVER.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>After we run the command, let&rsquo;s check our container list,</p>
<p><img loading="lazy" src="./assets/0*hjPRmsOYTMCz4gA0.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>As you can see, our <strong><code>test-mongo</code></strong> is already up and running. In our case, you can see. In our case, you can see <strong><code>PORTS</code></strong> section of <strong><code>test-mongo</code></strong> container, we can access the container by using port <strong><code>27017</code></strong>.</p>
<p>Let’s try connecting to MongoDB. You can use a DB client that supports MongoDB connections like <a href="https://robomongo.org/">Robo3T</a>, but I’m using Datagrip.</p>
<p><img loading="lazy" src="./assets/0*6Em6KVshs4zZg5e1.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>So, we can’t connect to our MongoDB. Why is this happening? Well, this is because <strong><code>PORTS</code></strong> the info that we see before is port on the container. The container’s behavior is that it will create an isolate the system, which means that we can’t access the system without exposing the port, so it can’t access the outside of the container.</p>
<h3 id="open-port">Open Port<a hidden class="anchor" aria-hidden="true" href="#open-port">#</a></h3>
<p>So, how can we expose the container’s port? To achieve that, we should consider passing an argument <strong><code>-p</code></strong> or <strong><code>--port</code></strong> when we create the container, so the command will look like this</p>
<pre tabindex="0"><code>$ docker container create --name &lt;container-name&gt; -p &lt;external-port&gt;:&lt;container-port&gt; &lt;image-name&gt;:&lt;tag&gt;
</code></pre><p>Let’s try creating a new container</p>
<p><img loading="lazy" src="./assets/0*F_tfZuZmNnKMU1Lr.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>I will explain the command.</p>
<p><strong><code>container-port</code></strong> i is a predefined port that already assigns when building the Image. If we were using the Image that we get from the docker registry, we could see the documentation of the Image for ports information. In this case, MongoDB using port <strong><code>27017</code></strong>.</p>
<p>And in the <strong><code>external-port</code></strong>, I use port <strong><code>8011</code></strong>. It means, when I’m using port <code>8011 </code>outside the container (or on my local machine), every request that comes through the port <strong><code>8011</code></strong> will be forwarded to port <strong><code>27017</code></strong> inside the container.</p>
<p>Try to start the new container, and with this, we can access MongoDB.</p>
<p><img loading="lazy" src="./assets/0*xQUf5T8AP2wrO2tB.png" alt=" "  />
<!-- raw HTML omitted --></p>
<h3 id="remove-container">Remove Container<a hidden class="anchor" aria-hidden="true" href="#remove-container">#</a></h3>
<p>To remove the container we use the command</p>
<pre tabindex="0"><code>$ docker container rm &lt;container-name&gt;
</code></pre><p>Let’s try to delete <strong><code>test-mongo</code></strong> container</p>
<p><img loading="lazy" src="./assets/0*rH76H7to-K5UzxJc.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>An error will occur. This happens because Docker wants that we to stop the container before we remove it. There is two way to handle this,</p>
<ul>
<li>Stop the container using</li>
</ul>
<pre tabindex="0"><code>$ docker container stop &lt;image-name&gt;
</code></pre><p>and then run the container remove command again</p>
<ul>
<li>Force delete the container by using an argument <strong><code>--force</code></strong></li>
</ul>
<pre tabindex="0"><code>$ docker container rm &lt;image-name&gt; --force
</code></pre><p>Please ensure that you know what you are doing when using this command.</p>
<p>For this example, I will use option 2,</p>
<p><img loading="lazy" src="./assets/0*4ox5O8cSfzQR2vxc.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>You can try to recheck the container list to ensure the container is already removed.</p>
<h3 id="remove-image">Remove Image<a hidden class="anchor" aria-hidden="true" href="#remove-image">#</a></h3>
<p>Same with removing the container, we can’t remove an image before all container that uses that Image is removed. To remove an image, you can use the command</p>
<pre tabindex="0"><code>$ docker image remove &lt;imange-name&gt;:&lt;tag&gt;
</code></pre><p>Let’s stop and remove the container, and then remove the <code>mongo</code> image.</p>
<p><img loading="lazy" src="./assets/0*zHNwgYc6uWtU9yNy.png" alt=" "  />
<!-- raw HTML omitted --></p>
<h3 id="docker-logs">Docker Logs<a hidden class="anchor" aria-hidden="true" href="#docker-logs">#</a></h3>
<p>We can see docker logs to help us debug our application inside the container. To do that, we can use the command</p>
<pre tabindex="0"><code>$ docker logs &lt;container-name&gt;
</code></pre><p>You can try to create some containers and check the container’s logs. This is an example of my Postgres container.</p>
<p><img loading="lazy" src="./assets/0*deyg0yHFLgnCXVZ6.png" alt=" "  />
<!-- raw HTML omitted --></p>
<h3 id="getting-through-inside-the-container">Getting through inside the container<a hidden class="anchor" aria-hidden="true" href="#getting-through-inside-the-container">#</a></h3>
<p>Even though the container is isolated from the outside of the container, Docker has some commands that we can use to pass a command inside our container. We can use the command</p>
<pre tabindex="0"><code>$ docker exec &lt;option&gt; &lt;container-name&gt; &lt;command&gt;
</code></pre><p>you can see more about docker exec <a href="https://docs.docker.com/engine/reference/commandline/exec/">here</a></p>
<p>I will demonstrate using my <code>postgre</code> named <code>dev-postgres</code>to get into Postgres client inside the container.</p>
<p><img loading="lazy" src="./assets/0*IpkehVoU2Ai9TUHA.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>You can see that I am running a command to show the database list inside the container <strong><code>-it</code></strong> means <strong><code>interactive</code></strong> (Keep STDIN open) and tty (Allocate a pseudo-TTY).</p>
<h2 id="create-image-with-dockerfile">Create Image with Dockerfile<a hidden class="anchor" aria-hidden="true" href="#create-image-with-dockerfile">#</a></h2>
<p>We already use Docker with the Image from the container registry, but how if we want to create an Image? Here comes the Dockerfile. Dockerfile is a simple text file that consists of instructions to build Docker images. Dockerfile consists of commands that guide you on how to build a specific Docker image.</p>
<p>For example, we need to prepare some application code to demonstrate how to build an application image. We will create 2 files, the application code, and the Dockerfile. For the application code, I will make a simple HTTP app using Go. You don’t need to have Go runtime on your computer because we will have our app inside the container then have Go runtime in it.</p>
<h3 id="prepare-an-app">Prepare an app<a hidden class="anchor" aria-hidden="true" href="#prepare-an-app">#</a></h3>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;net/http&#34;
)

func main() {


	// * Handle Route &#34;/&#34;
	http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, &#34;&lt;h1&gt;Hello Docker!&lt;/h1&gt;&#34;)
	})


    http.ListenAndServe(&#34;:8000&#34;, nil)
}
</code></pre><h3 id="create-a-dockerfile">Create a Dockerfile<a hidden class="anchor" aria-hidden="true" href="#create-a-dockerfile">#</a></h3>
<pre tabindex="0"><code># BUILD IMAGE FROM EXISTING IMAGE
# Line with &#39;#&#39; will not executed

# 1. Call the image
# FROM &lt;image name&gt;:&lt;tag&gt;
# for the base we will use golang image version 1.15

FROM golang:1.15

# 2. Copy file that needed in this image
# COPY &lt;source&gt; &lt;destination&gt;
# we will put file main.go in /app/main.go inside the container

COPY main.go /app/main.go

# 3. Telling the image how to run the app
# CMD [&lt;add command using array&gt;]

CMD [&#34;go&#34;, &#34;run&#34;, &#34;/app/main.go&#34;] # same with &#34;go run /app/main.go&#34;
</code></pre><h2 id="build-image">Build Image<a hidden class="anchor" aria-hidden="true" href="#build-image">#</a></h2>
<p>we can use 3 way to build an image:</p>
<ul>
<li>simple way</li>
</ul>
<p><strong><code>docker build &amp;lt;path-to-dockerfile&amp;gt;</code></strong></p>
<ul>
<li>add a name in our image</li>
</ul>
<p><strong><code>docker build --tag &amp;lt;app name&amp;gt; &amp;lt;path-to-dockerfile&amp;gt;</code></strong></p>
<ul>
<li>add name and version number</li>
</ul>
<p><strong><code>docker build --tag &amp;lt;app name&amp;gt;:&amp;lt;version number&amp;gt; &amp;lt;path-to-dockerfile&amp;gt;</code></strong></p>
<pre tabindex="0"><code>$ docker build --tag app-golang:1.0 .
</code></pre><p><img loading="lazy" src="./assets/0*Xsbj-WN6tLB0RvGs.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>building an image using Dockerfile can be done in various ways, depends on your needs, and many Dockerfile syntaxes are often used when creating an image, such as:</p>
<ul>
<li>
<p>ENTRYPOINT</p>
</li>
<li>
<p>RUN</p>
</li>
<li>
<p>WORKDIR</p>
</li>
<li>
<p>ENV</p>
</li>
</ul>
<p>read this docker <strong><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">documentation</a></strong>, get to know all the syntax, and see the best practice of using it.</p>
<h3 id="create-our-app-container">Create our app container<a hidden class="anchor" aria-hidden="true" href="#create-our-app-container">#</a></h3>
<p>Let’s try to create a container for our app and run it. Then we can check our app using the browser.</p>
<p><img loading="lazy" src="./assets/0*TALOE2p29CL0ZU3e.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p><img loading="lazy" src="./assets/0*uiuLKVyh3ZF4qcIE.png" alt=" "  />
<!-- raw HTML omitted --></p>
<h3 id="upload-image-to-registry">Upload Image to Registry<a hidden class="anchor" aria-hidden="true" href="#upload-image-to-registry">#</a></h3>
<p><strong>Preparation</strong></p>
<ul>
<li>Login to your account at <a href="https://hub.docker.com/">https://hub.docker.com/</a></li>
</ul>
<p><img loading="lazy" src="./assets/0*YVcQbEVAaIkveydH.png" alt=" "  />
<!-- raw HTML omitted --></p>
<ul>
<li>Create New repository for the image</li>
</ul>
<p><img loading="lazy" src="./assets/0*UYcbh-y-KYzLUM2m.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p><strong>Push image</strong></p>
<p>We will use the docker command to push the image, <strong><code>docker push &amp;lt;repository name&amp;gt;:&amp;lt;tag&amp;gt;</code></strong></p>
<p><img loading="lazy" src="./assets/0*XEDdiw_VxWbqOBtJ.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>If we try to insert the command, we will get an error: <code>An image does not **exist locally ...</code>**</p>
<p><img loading="lazy" src="./assets/0*sD0pns7IMlt3Ctnw.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>This will happen because we create an image with a name that is different from our repository name. Let’s check the Image in our local, using:</p>
<pre tabindex="0"><code>$ docker images
</code></pre><p><img loading="lazy" src="./assets/0*36_F7TZYePUs609A.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>our local image is named <strong>app-golang</strong> but the docker registry wants <strong>repoerna/example-go-app</strong>.</p>
<p>To resolve this, we need to do create the image with different names by using</p>
<pre tabindex="0"><code>$ docker tag &lt;local-image&gt;:&lt;tagname&gt; &lt;reponame&gt;:&lt;tagname&gt;
</code></pre><p>check docker images in our local, we will see the new image created,</p>
<p><img loading="lazy" src="./assets/0*dTRJ9_THERRPwG3G.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>after that, we can push to the repository, by using the same command we used before</p>
<p><img loading="lazy" src="./assets/0*LD-ZZ5te6hVGme7c.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>Oops! We still get an error, our request to push is denied. It is because, our local docker didn’t know, where to push the image.</p>
<p>We need to login, by using</p>
<pre tabindex="0"><code>$ docker login
</code></pre><p>input your account credential for the docker hub</p>
<p><img loading="lazy" src="./assets/0*A06ZHuZ6ldMe9mIf.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>after we logged in, let&rsquo;s try to push again</p>
<p><img loading="lazy" src="./assets/0*UYXhXhPU0azIETzO.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>Alright! We success push our local image to the remote repository, lets check in the docker hub</p>
<p><img loading="lazy" src="./assets/0*Ehaxrc9aZ3cOekpX.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>​ For details about the docker repository, you can read the <strong><a href="https://docs.docker.com/docker-hub/repos/">documentation</a></strong></p>
<h2 id="handle-image-with-environment-variable">Handle Image with Environment Variable<a hidden class="anchor" aria-hidden="true" href="#handle-image-with-environment-variable">#</a></h2>
<blockquote>
<p><em>An <strong>environment variable</strong> is a dynamic-named value that can affect the way running processes will behave on a computer. They are part of the environment in which a process runs. <strong>— Wikipedia</strong></em></p>
</blockquote>
<p>An environment variable is rarely used directly. It is usually used by a program to configure itself. In software development, some configurations for the program/ application are set by using an environment variable. If we want our program to change some configuration, we can achieve this by changing the environment variable without changing the code.</p>
<p><img loading="lazy" src="./assets/0*pZDz76DYxmD5gBHN.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>in Linux or macOS, you can see your OS environment variable using the command</p>
<pre tabindex="0"><code>$ printenv
</code></pre><p>if you using Windows, you can access the environment variable by open <strong>Control Panel &gt; Advanced system settings &gt; Environment Variable</strong>. You will see the Environment Variable window.</p>
<p><img loading="lazy" src="./assets/0*PAYkgBZPXOpWkh93.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>If we want to dockerize our program that needs an environment variable, we should add some commands before running the container.
To give you an example, let’s update our program to handle some environment variables. We will add a new route to manage the environment variable.</p>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;net/http&#34;
	&#34;os&#34;
)

func main() {
package main

import (
	&#34;fmt&#34;
	&#34;net/http&#34;
	&#34;os&#34;
)

func main() {
	// * this will set env variable MYNAME
	// os.Setenv(&#34;MYNAME&#34;, &#34;REPOERNA&#34;)

	// * get env variable MYNAME
	appPort := os.Getenv(&#34;APP_PORT&#34;)
	port := fmt.Sprintf(&#34;:%s&#34;, appPort)

	myName := os.Getenv(&#34;MYNAME&#34;)
	txt := fmt.Sprintf(&#34;&lt;h1&gt;Hello, %s&lt;/h1&gt;&#34;, myName) // &lt;-- env var MYNAME will be used in this line

	// * Handle Route &#34;/&#34;
	http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, &#34;&lt;h1&gt;Hello Docker!&lt;/h1&gt;&#34;)
	})

	// * Handle route &#34;/myname&#34;
	http.HandleFunc(&#34;/myname&#34;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, txt)
	})

	http.ListenAndServe(port, nil) // &lt;-- env var APP_PORT will be used in this line
}
</code></pre><p>Remember, in our program, we need two environment variables, APP_PORT and MYNAME. After updating our program, rebuild it without changing the Dockerfile.</p>
<pre tabindex="0"><code>$ docker build --tag app-golang:1.0 .
</code></pre><p>and then create a container using the image, and add <code>-e</code>to add an environment variable</p>
<pre tabindex="0"><code>$ docker container create --name golang-test-env -p 8080:8080 -e APP_PORT=8080 -e MYNAME=REPOERNA app-golang:1.0
</code></pre><p>after the container is created, let’s inspect the environment variable in it by using the command</p>
<pre tabindex="0"><code>$ docker container inspect golang-test-env
</code></pre><p>In the list, you will see in <code>Env</code> with <code>APP_PORT</code> and <code>MYNAME.</code> The value is the same as the command that we type before. For <code>PATH</code>, <code>GOLANG_VERSION</code>, <code>GOPATH</code> are automatically added, because we use golang in our Dockerfile.</p>
<p><img loading="lazy" src="./assets/0*wmEqsXjz1kqcUuwO.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>So let&rsquo;s run the container, to check our program is working</p>
<pre tabindex="0"><code>$ docker container start golang-test-env
</code></pre><p>if no error occurred, open in browser <em>localhost:8080/myname</em>, it will show the <code>MYNAME</code> environment variable value.</p>
<p><img loading="lazy" src="./assets/0*XsPvOsnitBnMACBo.png" alt=" "  />
<!-- raw HTML omitted --></p>
<ul>
<li>Note: when using a Dockerfile to create an image, you can specify the environment variable inside your Dockerfile. Please see the official documentation on how to implement that.</li>
</ul>
<h2 id="integrate-container-networking">Integrate Container Networking<a hidden class="anchor" aria-hidden="true" href="#integrate-container-networking">#</a></h2>
<p>In this section, we will talk about connecting containers to another container. Let say we have a web server that needs to communicate with Postgres for its database and Redis for its caching or session storage.</p>
<p><img loading="lazy" src="./assets/0*2-1_thdvJ4ZlfwJQ.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>So, we will prepare 3 containers, one for the app, one for Postgres, and one for Redis. Before that, let’s prepare our app. We will be using our previous app and add some code to connect with Postgres and Redis.</p>
<h3 id="update-our-app">Update our app<a hidden class="anchor" aria-hidden="true" href="#update-our-app">#</a></h3>
<p><strong>main.go</strong></p>
<p>We will add some database connections to our app.</p>
<pre tabindex="0"><code>Package main

import (
	&#34;database/sql&#34;
	&#34;fmt&#34;
	&#34;net/http&#34;
	&#34;os&#34;

	&#34;github.com/go-redis/redis&#34;
	_ &#34;github.com/lib/pq&#34;
)

func main() {

	dbHost := os.Getenv(&#34;DB_HOST&#34;)
	dbPort := 5432
	dbUser := &#34;postgres&#34;
	dbPass := &#34;Secure123&#34;
	dbName := &#34;docker-demo&#34;
	redisHost := os.Getenv(&#34;REDIS_HOST&#34;)
	redisAddr := fmt.Sprintf(&#34;%s:6379&#34;, redisHost)
	redisPass := &#34;&#34; //no password set
	redisDB := 0    //default db

	// * setup postgre connection
	dsn := fmt.Sprintf(&#34;host=%s port=%d user=%s &#34;+
		&#34;password=%s dbname=%s sslmode=disable&#34;,
		dbHost, dbPort, dbUser, dbPass, dbName)
	db, err := sql.Open(
		&#34;postgres&#34;,
		dsn,
	)
	if err != nil {
		fmt.Println(err)
	}

	// * Ping for test the connection
	if err = db.Ping(); err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(&#34;DB Postgres Connected !&#34;)
	}

	// * setup redis connection
	rdb := redis.NewClient(&amp;redis.Options{
		Addr:     redisAddr,
		Password: redisPass,
		DB:       redisDB,
	})

	// * Ping for test the connection
	pong, err := rdb.Ping().Result()
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(pong)
		fmt.Println(&#34;Redis Connected !&#34;)
	}

	// * get env variable MYshNAME
	appPort := os.Getenv(&#34;APP_PORT&#34;)
	// handle for default port
	if appPort == &#34;&#34; {
		appPort = &#34;8080&#34;
	}
	port := fmt.Sprintf(&#34;:%s&#34;, appPort)

	// myName := os.Getenv(&#34;MYNAME&#34;)
	// txt := fmt.Sprintf(&#34;&lt;h1&gt;Hello, %s&lt;/h1&gt;&#34;, myName)

	// * Handle Route &#34;/&#34;
	http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, &#34;&lt;h1&gt;Hello Docker!&lt;/h1&gt;&#34;)
	})

	// * Handle route &#34;/myname&#34;
	// http.HandleFunc(&#34;/myname&#34;, func(w http.ResponseWriter, r *http.Request) {
	// 	fmt.Fprintf(w, txt)
	// })

	http.ListenAndServe(port, nil)
}
</code></pre><p>For Postgres and Redis hostname, we will use an environment variable, and because we are using Redis, we need to use modules in our go app. Therefore we need to update our Dockerfile to handle go modules.</p>
<p><strong>Dockerfile</strong></p>
<pre tabindex="0"><code>FROM golang:1.15

ENV GO111MODULE=on

WORKDIR /app


RUN go mod init

COPY . .

RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build

EXPOSE 8080
CMD [&#34;go&#34;, &#34;run&#34;, &#34;/app/main.go&#34;]
</code></pre><p>After the app is ready, we will continue preparing the container, and don’t forget to clean up the previous container</p>
<h3 id="create-container-1">Create Container<a hidden class="anchor" aria-hidden="true" href="#create-container-1">#</a></h3>
<ul>
<li>Rebuild our golang app image</li>
</ul>
<pre tabindex="0"><code>$ docker build — tag app-golang:1.0 .
</code></pre><ul>
<li>Create golang app container</li>
</ul>
<pre tabindex="0"><code>$ docker container create — name golang-docker -e REDIS_HOST=localhost -e DB_HOST=localhost -p 8080:8080 app-golang:1.0
</code></pre><ul>
<li>Create Postgres container</li>
</ul>
<pre tabindex="0"><code>$ docker container create --name postgres-docker -p 5432:5432 -e POSTGRES_DB=docker-demo -e POSTGRES_PASSWORD=mysecretpassword postgres
</code></pre><ul>
<li>Create Redis container</li>
</ul>
<pre tabindex="0"><code>$ docker container create --name redis-docker -p 6379:6379 redis
</code></pre><p>let’s see our created containers</p>
<p><img loading="lazy" src="./assets/0*HFDJGoXnk83igAEb.png" alt=" "  />
<!-- raw HTML omitted --></p>
<h3 id="start-containers">Start Containers<a hidden class="anchor" aria-hidden="true" href="#start-containers">#</a></h3>
<p>start all 3 containers</p>
<pre tabindex="0"><code>$ docker container start redis-docker postgres-docker golang-docker
</code></pre><p>check our app container</p>
<pre tabindex="0"><code>$ docker container logs golang-docker
</code></pre><p><img loading="lazy" src="./assets/0*1AmAwa9G-j29H7Py.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>As I expected, an error will happen because we were trying to connect to localhost. We can’t connect to localhost because Redis and Postgres are in a different containers. We need to use the container name as the hostname. So, let’s delete <code>golang-docker</code>container and re-create it.</p>
<pre tabindex="0"><code>$ docker container create --name golang-docker -e REDIS_HOST=redis-docker -e DB_HOST=postgres-docker -p 8080:8080 app-golang:1.0
</code></pre><p>Start the container, and check logs again.</p>
<p><img loading="lazy" src="./assets/0*YQppcLN1MBVvqgQU.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>We still can’t connect to Redis and Postgres. What happens here? As you can see, there is an error occur in our app. This will occurred because our program still can’t find Redis and Postgres. Before using <em>localhost</em> or <em>127.0.0.1</em> as the host, localhost refers to the hostname in the current computer or system.</p>
<p>As you know, <strong>when creating a container, the system inside it will be isolated from another container</strong>. Even if we want the container to connect to our laptop or computer, we need to expose the container port and mapping it to our computer port. But, after we changed the hostname to the container name, errors still occurred. So <strong>how to make containers communicate with each other?</strong></p>
<h3 id="setup-container-network">Setup Container Network<a hidden class="anchor" aria-hidden="true" href="#setup-container-network">#</a></h3>
<p>To achieve that, we need to use <strong>docker network</strong>, which will help us connecting containers</p>
<pre tabindex="0"><code>$ docker network --help
</code></pre><ul>
<li>Create docker network</li>
</ul>
<pre tabindex="0"><code>$ docker network create example-network
</code></pre><p>we can check our created network by using</p>
<pre tabindex="0"><code>$ docker network ls
</code></pre><ul>
<li>Set container network</li>
</ul>
<pre tabindex="0"><code>$ docker network connect example-network golang-docker
$ docker network connect example-network redis-docker
$ docker network connect example-network postgres-docker
</code></pre><p>After we connect the containers to the network, let&rsquo;s inspect our container</p>
<pre tabindex="0"><code>$ docker container inspect golang-docker
</code></pre><p>You can see in &ldquo;Networks&rdquo;, there is <strong>example-network</strong>, that we created before.</p>
<p><img loading="lazy" src="./assets/0*Qyl1tawEZVOEhH9K.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>Let&rsquo;s restart our golang-app container, and check the logs</p>
<pre tabindex="0"><code>$ docker container restart golang-docker
</code></pre><p><img loading="lazy" src="./assets/0*pvbPQxD-9he_2nkr.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>Finally, it&rsquo;s connected! Congratulations to us!</p>
<h2 id="manage-data-in-docker">Manage Data in Docker<a hidden class="anchor" aria-hidden="true" href="#manage-data-in-docker">#</a></h2>
<p>When creating an application, it is best to make it stateless. It means no data are saved or the data stored somewhere else. However, some applications need to be stateful, for example, databases. How do we run a stateful application? How can we save the data so when we delete a container, the data will still remain?</p>
<p>Actually, you can read the documentation about that <a href="https://docs.docker.com/storage/">here</a></p>
<p>There are many ways to manage data in Docker. Usually, I will use bind mounts, but we will try to use volume this time.</p>
<p>In this example, we will try to create a MongoDB container. To manage data, first, we must know where is application save its data. If you use <a href="https://hub.docker.com/_/mongo">mongo image from docker hub</a>, we can see in the description at subtitle Where to store data, from there we can see where is mongo data reside, it’s in /data/db.</p>
<p>So, let’s start…</p>
<ul>
<li>Pull image</li>
</ul>
<pre tabindex="0"><code>$ docker pull mongo
</code></pre><ul>
<li>Create new volume</li>
</ul>
<pre tabindex="0"><code>$ docker create volume mongo-test
</code></pre><p>The volume will be used in our container. This is where data will be saved. You can check where is volume stored in your computer by using the command:</p>
<pre tabindex="0"><code>$ docker volume inspect &lt;volume-name&gt;
</code></pre><p><img loading="lazy" src="./assets/0*ArHQfIx1102s6WvA.png" alt=" "  />
<!-- raw HTML omitted --></p>
<ul>
<li>Create container</li>
</ul>
<pre tabindex="0"><code>$ docker container create --name mongo-docker -v mongo-test:/data/db -p 27017:27017
</code></pre><p>In this command we use <strong><code>-v &amp;lt;docker_volume&amp;gt;:&amp;lt;data location in application&amp;gt;</code></strong> to create volume binding between docker and our computer.</p>
<ul>
<li>Start container</li>
</ul>
<pre tabindex="0"><code>$ docker container start mongo-docker
</code></pre><ul>
<li>Open mongo DB using mongo client, here I’m using <a href="https://studio3t.com/">Studio 3T</a></li>
</ul>
<p><img loading="lazy" src="./assets/0*MzLuE7ZhxAtTI8ey.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>By default, there are 3 DB like above in the newly created MongoDB. Let’s create a new DB and add new data in there</p>
<ul>
<li>Create a new DB and insert some data</li>
</ul>
<p><img loading="lazy" src="./assets/0*jAivSg-jczuDUmV3.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>Here, I already create new <strong><code>DB</code></strong> named test_db, a collection name <strong><code>test_collection</code></strong>, and inside that collection there 1 document</p>
<ul>
<li>Stop and delete the container</li>
</ul>
<pre tabindex="0"><code>$ docker container stop mongo-docker
</code></pre><p><img loading="lazy" src="./assets/0*5WcNdaNN0VG2-DFp.png" alt=" "  />
<!-- raw HTML omitted --></p>
<pre tabindex="0"><code>$ docker container rm mongo-docker
</code></pre><p><img loading="lazy" src="./assets/0*Op7jY9h7LGA1-9Wv.png" alt=" "  />
<!-- raw HTML omitted --></p>
<ul>
<li>
<p>Create and start the container again using the same command in steps 3 and 4</p>
</li>
<li>
<p>Check DB again using Mongo client</p>
</li>
</ul>
<p><img loading="lazy" src="./assets/0*q3ve1yinBt2eNpP2.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>You will see, that your data is still there. Congratulation!</p>
<p>That is one method of how to manage data in docker, there is still many ways to manage data in docker. Please be sure to read the <a href="https://docs.docker.com/storage/">documentation</a>. In there you will know what method to use and how to use it for your needs.</p>
<h2 id="docker-compose">Docker Compose<a hidden class="anchor" aria-hidden="true" href="#docker-compose">#</a></h2>
<p>We already learn to integrate our containers. In the previous example, we use 3 containers, but what if our application or system needs more than that? Doing it manually every step will be a problem, right? So, Docker Compose will help us automate that process.</p>
<p>Basically, there are 3 steps to use Docker Compose, these steps are:</p>
<ol>
<li>
<p>Define your app’s environment with a <strong><code>Dockerfile</code></strong> so it can be reproduced anywhere.</p>
</li>
<li>
<p>Define the services that make up your app in <strong><code>docker-compose.yml</code></strong> to be run together in an isolated environment.</p>
</li>
<li>
<p>Run <strong><code>docker-compose up</code></strong> and Compose starts and runs your entire app.</p>
</li>
</ol>
<p>In step 1, we already learn how to create <strong><code>Dockerfile</code></strong> so we will focus on step 2, how to create <strong><code>docker-compose.yml</code></strong> file, and step 3, how to run it.</p>
<p>Let&rsquo;s create our**<code>docker-compose.yml</code>** ,</p>
<pre tabindex="0"><code>version: &#34;3.9&#34; # optional since v1.27.0

services:
  db:
    container_name: postgres-comose
    image: postgres
    ports:
      - 5432:5432
    networks:
      - compose-network
    environment:
      - POSTGRES_DB=docker-demo
      - POSTGRES_PASSWORD=mysecretpassword
  cache:
    container_name: redis-compose
    image: redis
    ports:
      - 6379:6379
    networks:
      - compose-network
  app:
    container_name: golang-compose
    # image: app-golang:1.0
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - 8080:8080
    restart: unless-stopped
    networks:
      - compose-network
    depends_on:
      - db
      - cache
    environment:
      - REDIS_HOST=redis-compose
      - DB_HOST=postgres-compose
      - MYNAME=REPOERNA

networks:
  compose-network:
    name: new-example-network
</code></pre><p>*<strong>Note: in the app service environment, we use REDIS_HOST and DB_HOST using Redis and Postgres container name</strong></p>
<p>Okay, I will explain what we write. At the root of the file, we have:</p>
<ul>
<li>
<p><strong><code>version</code></strong> define Compose release. Each release has different features and parameters that we can use. You can read the compatibility matrix of each version <strong><a href="https://docs.docker.com/compose/compose-file/compose-versioning/">here</a></strong>. If you omit the <strong><code>version</code>by</strong> default, it will use version 1.</p>
</li>
<li>
<p><strong><code>services</code></strong> defined all services in our system. In our example, before we use Postgres, Redis, and golang app, those 3 services will be defined here.</p>
</li>
<li>
<p><strong><code>network</code></strong> define network will be used, if you haven’t created the network, it will be automatically created, and you can create more than one network here.</p>
</li>
</ul>
<p>Inside services, there is the service name; we have DB, cache, and app. On every service, we will define a parameter that will be used on each service. these parameters are:</p>
<ul>
<li>
<p><strong><code>container_name</code></strong> defines name services container.</p>
</li>
<li>
<p><strong><code>image</code></strong> define an image that will be used for creating the container.</p>
</li>
<li>
<p><strong><code>port</code></strong> define port binding to exposed the port inside a container with the environment outside.</p>
</li>
<li>
<p><strong><code>networks</code></strong> define a network that will be used by services.</p>
</li>
<li>
<p><strong><code>depends_on</code></strong> define other services that needed by app services.</p>
</li>
<li>
<p><strong><code>environment</code></strong> define environment variable inside the container.</p>
</li>
</ul>
<p>In <strong><code>app</code></strong> service, instead of using an image, we will use <code>build</code> to build the image, below <strong><code>build</code></strong> there is <strong><code>context</code></strong> that define the location of Dockerfle that will be used to build the image and <strong><code>dockerfile</code></strong> to define Dockerfile filename.</p>
<p>To run Docker Compose, we need to use some commands, you can check in your terminal by using</p>
<pre tabindex="0"><code>$ docker-compose
</code></pre><p>It will show you a list of commands and a short description of its function. You need to know how to use it properly. There are common commands that I frequently used:</p>
<ul>
<li><strong><code>docker-compose build</code></strong></li>
</ul>
<p>It will rebuild the image if you are using <strong><code>build</code></strong> instead of <strong><code>image</code></strong> in your <strong><code>docker-compose.yml</code></strong>, if your services using existing images, there will be an error occurred.</p>
<ul>
<li><strong><code>docker-compose up -d</code></strong></li>
</ul>
<p>It will create and start containers, it is best to use<code>-d</code> or daemon mode, to run the process in the background.</p>
<ul>
<li><strong><code>docker-compose down</code></strong></li>
</ul>
<p>it will stop and remove containers, networks, images, and volumes. Please beware if you using a database in your services, when you use this command, the data will also be removed.</p>
<p>So, let&rsquo;s run the Docker Compose</p>
<ul>
<li>Rebuild the image</li>
</ul>
<pre tabindex="0"><code>$ docker-compose build
</code></pre><p>this process will be the same with <strong><code>docker build</code></strong></p>
<ul>
<li>Start services</li>
</ul>
<pre tabindex="0"><code>$ docker-compose up -d
</code></pre><p><img loading="lazy" src="./assets/0*c_rG9VRdyk36akpP.png" alt=" "  />
<!-- raw HTML omitted --></p>
<ul>
<li>Check our application</li>
</ul>
<p><img loading="lazy" src="./assets/0*hm94NkBt7nxwmiyQ.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p><img loading="lazy" src="./assets/0*U8x1gAWZa6OuW-K7.png" alt=" "  />
<!-- raw HTML omitted --></p>
<p>Our services are up! No error occurred.</p>
<ul>
<li>Clean Up</li>
</ul>
<pre tabindex="0"><code>$ docker-compose down
</code></pre><p><img loading="lazy" src="./assets/0*ABuD6vGLfoclaqvH.png" alt=" "  />
<!-- raw HTML omitted --></p>
<h2 id="docker-tools--kitematic">Docker Tools — Kitematic<a hidden class="anchor" aria-hidden="true" href="#docker-tools--kitematic">#</a></h2>
<p>Docker tool is software that you can use to help you manage Docker using GUI. Docker has its own tools called Docker Desktop, but it is only for Windows and macOS. For Linux, I preferred using Kitematic because it also can run on Windows, macOS. It also has more features than Docker Desktop.</p>
<p>The features are:</p>
<ol>
<li>
<p>Create, delete, start &amp; stop a container</p>
</li>
<li>
<p>View containers logs</p>
</li>
<li>
<p>Managing volumes</p>
</li>
<li>
<p>Add environment variables</p>
</li>
<li>
<p>Command-Line Access</p>
</li>
</ol>
<p>You can see the details on</p>
<p>You can see the details on <a href="https://kitematic.com/">Kitematic website</a> or <a href="https://docs.docker.com/kitematic/userguide/">docker documentation</a>.</p>
<h2 id="docker-cheat-sheethttpswwwdockercomsitesdefaultfilesd82019-09docker-cheat-sheetpdf"><a href="https://www.docker.com/sites/default/files/d8/2019-09/docker-cheat-sheet.pdf">Docker Cheat Sheet</a><a hidden class="anchor" aria-hidden="true" href="#docker-cheat-sheethttpswwwdockercomsitesdefaultfilesd82019-09docker-cheat-sheetpdf">#</a></h2>
<h2 id="refrence">Refrence<a hidden class="anchor" aria-hidden="true" href="#refrence">#</a></h2>
<p>[1] <a href="https://www.simplilearn.com/tutorials/docker-tutorial/what-is-dockerfile">What Is Dockerfile: Everything You Need to Know</a></p>
<p>[2] <a href="https://www.oracle.com/cloud-native/container-registry/what-is-docker/">Docker Containers and Container Cloud Services</a></p>
<p>[3] <a href="http://oracle-help.com/oracle-cloud/basic-docker-oracle/">Basic about Docker in the Oracle</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://repoerna.github.io/tags/golang/">golang</a></li>
      <li><a href="https://repoerna.github.io/tags/docker/">docker</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://repoerna.github.io/posts/mindsets-of-self-learner/">
    <span class="title">« Prev</span>
    <br>
    <span>Mindsets of Self-learner</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Tutorial — Complete Beginner’s Guide on twitter"
        href="https://twitter.com/intent/tweet/?text=Docker%20Tutorial%e2%80%8a%e2%80%94%e2%80%8aComplete%20Beginner%e2%80%99s%20Guide&amp;url=https%3a%2f%2frepoerna.github.io%2fposts%2fdocker-tutorial-complete-beginners-guide%2f&amp;hashtags=golang%2cdocker">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Tutorial — Complete Beginner’s Guide on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frepoerna.github.io%2fposts%2fdocker-tutorial-complete-beginners-guide%2f&amp;title=Docker%20Tutorial%e2%80%8a%e2%80%94%e2%80%8aComplete%20Beginner%e2%80%99s%20Guide&amp;summary=Docker%20Tutorial%e2%80%8a%e2%80%94%e2%80%8aComplete%20Beginner%e2%80%99s%20Guide&amp;source=https%3a%2f%2frepoerna.github.io%2fposts%2fdocker-tutorial-complete-beginners-guide%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Tutorial — Complete Beginner’s Guide on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2frepoerna.github.io%2fposts%2fdocker-tutorial-complete-beginners-guide%2f&title=Docker%20Tutorial%e2%80%8a%e2%80%94%e2%80%8aComplete%20Beginner%e2%80%99s%20Guide">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Tutorial — Complete Beginner’s Guide on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frepoerna.github.io%2fposts%2fdocker-tutorial-complete-beginners-guide%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Tutorial — Complete Beginner’s Guide on whatsapp"
        href="https://api.whatsapp.com/send?text=Docker%20Tutorial%e2%80%8a%e2%80%94%e2%80%8aComplete%20Beginner%e2%80%99s%20Guide%20-%20https%3a%2f%2frepoerna.github.io%2fposts%2fdocker-tutorial-complete-beginners-guide%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Tutorial — Complete Beginner’s Guide on telegram"
        href="https://telegram.me/share/url?text=Docker%20Tutorial%e2%80%8a%e2%80%94%e2%80%8aComplete%20Beginner%e2%80%99s%20Guide&amp;url=https%3a%2f%2frepoerna.github.io%2fposts%2fdocker-tutorial-complete-beginners-guide%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://repoerna.github.io">purnasatria</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a> &
        <a href="https://github.com/catppuccin/catppuccin" rel="noopener" target="_blank">Catppuccin</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
