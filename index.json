[{"content":"Requirements Before you begin, ensure that your system meets the following requirements:\nUbuntu 16.04–22.04\nOracle JRE version 8, Oracle JDK version 11–19, or Open JDK version 11–19\nRequired tools: certutil, openssl, and xterm\nsudo apt install libnss3-tools sudo apt-get install openssl sudo apt-get install xterm Required libraries: libpam0g:i386, libx11-6:i386, libstdc++6:i386, and libstdc++5:i386\nsudo apt-get install libpam0g:i386 sudo apt-get install libx11-6:i386 sudo apt-get install libstdc++6:i386 sudo apt-get install libstdc++5:i386 You can see the full requirements here.\nInstallation Download Installation Script To set up Checkpoint VPN on your machine, you need to download two shell script files:\nsnx_install.sh\ncshell_install.sh\nYou can get these files from your company’s Mobile Access VPN page. Once you’ve logged in, click on the Settings button, and then click on Download for both SSL Network Extender (snx_install.sh) and Check Point Mobile Access Portal Agent (cshell_install.sh).\nChange Permission to Execute the File Before running the installation scripts, you need to change their permissions to make them executable. Use the following commands:\nchmod a+rx snx_install.sh chmod +x cshell_install.sh Install the Scripts Now, you can install the scripts using the following commands:\nsnx_install.sh\nsudo ./snx_install.sh If the installation is successful, you’ll see the message Installation successful.\ncshell_installation.sh\nsudo ./cshell_install.sh If the installation is successful, you’ll see the following messages:\nStart Check Point Mobile Access Portal Agent installation Extracting Mobile Access Portal Agent... Done Installing Mobile Access Portal Agent... Done Installing certificate... Done Starting Mobile Access Portal Agent... Start the Mobile Access Portal Agent Finally, you can start the Mobile Access Portal Agent using the following command:\n/usr/bin/cshell/launcher If the agent starts successfully, you’ll see the following message:\nLAUNCHER\u0026gt; Starting CShell... LAUNCHER\u0026gt; CShell Started Congratulations! You’ve successfully installed and started Checkpoint VPN on your Ubuntu 22.04 machine.\n","permalink":"https://repoerna.github.io/posts/installing-checkpoint-vpn-client-on-ubuntu-22-04/","summary":"This is a step-by-step guide to install Checkpoint VPN in Ubuntu 22.04 x64-bit version.","title":"Installing Checkpoint VPN Client on Ubuntu 22.04"},{"content":" “Picture your brain forming new connections as you meet the challenge and learn. Keep ongoing.” — Carol Dweck\nOur Thoughts Define Us Thoughts will determine a person’s behaviour. Our mindset will affect our character, habits, behaviour, and attitude, that strongly influenced by the belief system, value system, family values, education, and the environment. Therefore we must ensure that our mindset is only shaped and influenced by right and good values.\nIf we want to have a quality life, we must change our mindset to optimally develop our potential and talents.\nMindset is the essence of self-learning that determines how we view potential, intelligence, challenges, and opportunities as a process that must be pursued with perseverance, hard work, commitment to achieve our life goals.\nThe self-learning process always starts from formulating a vision and mission of life to guide us to success. But that alone is not enough; we need a growth mindset that will be a catalyst in responding to every opportunity, challenge, and change, making it a process carried out with patience, effort, and ongoing commitment to developing our quality of life.\nA person with a growth mindset will always view talent and intelligence are not a gift (already determined) but can be obtained through certain efforts. Therefore, people with a growth mindset will try to take advantage of the opportunities and challenges that come their way. They interpret success as “trying to do something better” and failure as “lack of skills and experience”, therefore every failure needs to be responded to with efforts to work harder, more diligently, and be more motivated.\nA Gallup survey on “Characteristics of Successful People in America”​ explains that almost all successful people are those who have a growth mindset. These mindsets include hard work, clear goals, a high desire to learn, never stop learning in one field, value every thought, and constantly strive to change and grow. A growing life can be achieved because the right mindset has been applied in successful people’s character, habits, attitudes, and behaviour.\nA good learner always follows the principle that makes him a person who never gives up, is always open to change, and is willing to change.\nSuccess is about learning, self-development, and the process of becoming more competent. Whatever the reason may be, the search for meaning in what we do is critical\nThere is no success without learning. There is no learning if there is no goal to be achieved. Learn to accept change, challenges, and opportunities. Learn to always be curious to increase knowledge. Learn to be willing to change and grow.\nIntelligence is the process of learning something over time, meet challenges and make progress. Intelligence can continuously be improved through diligent and earnest effort. It is not something that has been set. Although some people are endowed with exceptional intelligence, we still can obtain intelligence by learning to face challenges and successfully make progress in every process.\nFailure is not the result. It is a problem that must be faced, studied, solved, and learned from. Failure is not the end of everything. It does not determine our future. For a person with a growth mindset, failure is an issue that needs to be addressed and solved with more adequate effort than before. Failure motivates people with a growth mindset to work better, focusing on improving their weaknesses and shortcomings.\nEffort is something to ignite abilities and turn them into achievements.\nEfforts will improve one’s capabilities, competencies, and abilities with determination and commitment to transform these abilities into achievements.\nEndless curiosity, as well as the quest for challenges.\nThe “primacy of knowledge” means that knowledge is superior to ignorance, conjecture, doubt, or unsubstantiated belief. “The primacy of seeking it” means that there is nothing more virtuous than travelling a path that leads to attaining it.\nThe soul of a learner is a never-ending desire to learn in everything. There is no time at all to stop that desire. Develop curiosity by seeking new challenges. Never satisfied with the current condition, but always looking for ways for improvement and development. When the desire is extinguished, the soul of the learner also dies.\nTake responsibility for the processes that lead to success and maintain it.\nOne should speak and act following what one learns and teaches. Putting into practice what one learns results in an increase of knowledge, a transformation of behaviour, and benefit to others.\nEvery process that forms the character and habits of success must be accounted for by maintaining the process when the challenges become more severe and complicated. Although perhaps the process should be pursued harder, more diligently, more enthusiastically than before. But this is what growth means. Will never face the same situation and challenges. But proactively looking for problems and challenges that are much tougher than before. A learner must continue maintaining and improving the character quality that brought him to his previous success.\nWilling to accept feedback and criticism for quality improvement and progress\nFeedback can be medicine or poison, depending on our attitude and mindset. A learner who is aware of the process, always looking for feedback for necessary improvement. Never allergic to harsh criticism, no matter how sharp the criticism is. For a learner, the number of criticisms does not determine his future, even though the criticism may be valid. If he faces failure and receives criticism, a learner with a growth mindset will be motivated to increase his efforts because his perspective views failure as lacking skills and experience. Criticism is the medicine that heals him.\nStarting to Become a Learner Photo by Clemens van Lay on Unsplash\nAnd when the identification has been made, we need to compile it in a clear and measurable action plan. After that, it takes a strong commitment and determination so that the objectives go well. If we encounter obstacles or setbacks, we need to rework our plans based on feedback and criticism.\nWhen success has begun to be achieved, we need to maintain that success and even improve it. Of course, this is an iterative process (circle process) to forming our character, habits, and behaviour to become a complete, qualified, and developing person. Be a good learner.\n","permalink":"https://repoerna.github.io/posts/mindsets-of-self-learner/","summary":"“Picture your brain forming new connections as you meet the challenge and learn. Keep ongoing.” — Carol Dweck\nOur Thoughts Define Us Thoughts will determine a person’s behaviour. Our mindset will affect our character, habits, behaviour, and attitude, that strongly influenced by the belief system, value system, family values, education, and the environment. Therefore we must ensure that our mindset is only shaped and influenced by right and good values.","title":"Mindsets of Self-learner"},{"content":"Prelude This post will give a basic tutorial on how to using Docker. The topics that will be explained are:\nWhat is Docker\nDocker Architecture\nStart using Docker (Guide to using basic commands)\nCreate Image using Dockerfile\nHandle Image using Environment Variable\nIntegrate Container Networking\nManage Data in Docker\nDocker Compose\nDocker Tools\nDocker Cheat-sheet\nThis post will be pretty long, and I hope you will enjoy it, and feel free to give feedback to help me improve this tutorial.\nThanks, and enjoy it!\nWhat Is Docker? Docker is a configuration management tool that is used to automate the deployment of software in lightweight containers. These containers help applications to work efficiently in different environments. By using Docker, developers can quickly build, pack, ship, and run applications as lightweight, portable, self-sufficient containers and running virtually anywhere.¹ Containers allow developers to package an application with its dependencies and deploy it as a single unit. By providing prebuilt and self-sustaining application containers, developers can focus on the application code and use it without worrying about the underlying operating system or deployment system.²\nDocker Architecture The core concepts of Docker are images and containers. A Docker image contains everything that is needed to run your software: the code, a runtime (for example, Java Virtual Machine (JVM), drivers, tools, scripts, libraries, deployments, and more. A Docker container is a running instance of a Docker image. However, unlike in traditional virtualization with a type 1 or type 2 hypervisor, a Docker container runs on the host operating system’s kernel. Within a Docker Image, there is no separate operating system, as illustrated below.³\nDocker Architecture\nEvery Docker container has its own file system, network stack (and therefore its own IP address), process space, and defined resource limitations for CPU and memory. Since a Docker container does not have to boot an operating system, it starts up instantly. Docker is about isolation, i.e., separating the resources of a host operating system, as opposed to virtualization, i.e., providing a guest operating system on top of the host operating system.\nImage Image is a read-only file with a bunch of instructions. When these instructions are executed, it creates a Docker container. We can say that an Image is a template to create a container.\nContainer A container is a software package that has all the dependencies required to run an application. When running a container, it uses an isolated filesystem.\nContainer Registry Docker Container Registry is where we put Docker Image remotely before deploying it to the server. In another way, it is a standard way to store and distribute Docker images. It also helps improve access control and security of docker images stored in its repository. While managing the distribution of Images, it can also integrate with application development workflow. Developers can set up their own Container Registry because it is an open-source-based repository under the permissive Apache license. You can also use a hosted Container Service such as Docker Hub or Azure Container Registry, etc.\nInstalling a Docker I won’t cover how to install Docker. There are many tutorials on how to install Docker into your machine. For me, I prefer using the official document. You can see the instruction here.\nStart Using Docker After you install the Docker, let’s get into it!\nPull Image from Registry Check the image on our local\n$ docker images Image list\nif you newly install Docker, you won’t see anything on the list. You will just see the header result, REPOSITORY, TAG, IMAGE ID, CREATED, **SIZE**.\nPull the image\nTo pull an image you can use the command:\n$ docker pull \u0026lt;image-name\u0026gt; or for a specific image version\n$ docker pull \u0026lt;image-name\u0026gt;:\u0026lt;tag-name\u0026gt; For this example, we will use MongoDB image. You can check it here. If you open the link, you can see on the right, there is a command that tells you how to pull the image.\nDocker hub\nOn the Tags menu, you can see the available version of the image\nDocker hub tags menu\nCopy the image pull command, and run it on your terminal. You will see that the image is being pulled from the registry to our local machine.\nPulling image\nIf we do not specify the tag name, it will automatically pull the latest image on the registry. After Image pulling is finished, we can recheck the images list, you will see mongo on the list\nCreate Container Check running container.\nTo check the running container, you can use\n$ docker container ls It will show only the** **running container, but if you have some container that stopped, it won’t show on the list. To see all containers that we have, we can use\n$ docker container ls --all You can use --all or **-a**. It will show all the containers you have on your local machine. You can see on the image there are some containers running, and some containers stopped.\nYou can see on the image there are some containers running, and some containers stopped.\nCreating container\nThere are many ways to create a container. These commands are:\n$ docker container create \u0026lt;image-name\u0026gt; to create a container with a specific image tag\n$ docker container create \u0026lt;image-name\u0026gt;:\u0026lt;tag\u0026gt; to create a container with a predefined name, we can use --name argument on our command\n$ docker container create --name \u0026lt;some-container-name\u0026gt; \u0026lt;image-name\u0026gt;:\u0026lt;tag\u0026gt; For the example, let’s create a container for our pulled MongoDB image,\n$ docker container create --name test-mongo mongo let’s check it using our container,\nYou can see that there is no test-mongo container. This happens because using the container create command just creates the container and not started it. You can try usingdocker contaner ls -a command to see the container.\nYou can also create multiple containers from the same image with one condition; the container name must be different because the container name is unique. If you create a container without specifying the name, Docker will generate a random name for the container.\nStart Container After we create the container, we can run it using the command\n$ docker container start \u0026lt;container-name\u0026gt; After we run the command, let\u0026rsquo;s check our container list,\nAs you can see, our test-mongo is already up and running. In our case, you can see. In our case, you can see PORTS section of test-mongo container, we can access the container by using port 27017.\nLet’s try connecting to MongoDB. You can use a DB client that supports MongoDB connections like Robo3T, but I’m using Datagrip.\nSo, we can’t connect to our MongoDB. Why is this happening? Well, this is because PORTS the info that we see before is port on the container. The container’s behavior is that it will create an isolate the system, which means that we can’t access the system without exposing the port, so it can’t access the outside of the container.\nOpen Port So, how can we expose the container’s port? To achieve that, we should consider passing an argument -p or --port when we create the container, so the command will look like this\n$ docker container create --name \u0026lt;container-name\u0026gt; -p \u0026lt;external-port\u0026gt;:\u0026lt;container-port\u0026gt; \u0026lt;image-name\u0026gt;:\u0026lt;tag\u0026gt; Let’s try creating a new container\nI will explain the command.\ncontainer-port i is a predefined port that already assigns when building the Image. If we were using the Image that we get from the docker registry, we could see the documentation of the Image for ports information. In this case, MongoDB using port 27017.\nAnd in the external-port, I use port 8011. It means, when I’m using port 8011 outside the container (or on my local machine), every request that comes through the port 8011 will be forwarded to port 27017 inside the container.\nTry to start the new container, and with this, we can access MongoDB.\nRemove Container To remove the container we use the command\n$ docker container rm \u0026lt;container-name\u0026gt; Let’s try to delete test-mongo container\nAn error will occur. This happens because Docker wants that we to stop the container before we remove it. There is two way to handle this,\nStop the container using $ docker container stop \u0026lt;image-name\u0026gt; and then run the container remove command again\nForce delete the container by using an argument --force $ docker container rm \u0026lt;image-name\u0026gt; --force Please ensure that you know what you are doing when using this command.\nFor this example, I will use option 2,\nYou can try to recheck the container list to ensure the container is already removed.\nRemove Image Same with removing the container, we can’t remove an image before all container that uses that Image is removed. To remove an image, you can use the command\n$ docker image remove \u0026lt;imange-name\u0026gt;:\u0026lt;tag\u0026gt; Let’s stop and remove the container, and then remove the mongo image.\nDocker Logs We can see docker logs to help us debug our application inside the container. To do that, we can use the command\n$ docker logs \u0026lt;container-name\u0026gt; You can try to create some containers and check the container’s logs. This is an example of my Postgres container.\nGetting through inside the container Even though the container is isolated from the outside of the container, Docker has some commands that we can use to pass a command inside our container. We can use the command\n$ docker exec \u0026lt;option\u0026gt; \u0026lt;container-name\u0026gt; \u0026lt;command\u0026gt; you can see more about docker exec here\nI will demonstrate using my postgre named dev-postgresto get into Postgres client inside the container.\nYou can see that I am running a command to show the database list inside the container -it means interactive (Keep STDIN open) and tty (Allocate a pseudo-TTY).\nCreate Image with Dockerfile We already use Docker with the Image from the container registry, but how if we want to create an Image? Here comes the Dockerfile. Dockerfile is a simple text file that consists of instructions to build Docker images. Dockerfile consists of commands that guide you on how to build a specific Docker image.\nFor example, we need to prepare some application code to demonstrate how to build an application image. We will create 2 files, the application code, and the Dockerfile. For the application code, I will make a simple HTTP app using Go. You don’t need to have Go runtime on your computer because we will have our app inside the container then have Go runtime in it.\nPrepare an app package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { // * Handle Route \u0026#34;/\u0026#34; http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;\u0026lt;h1\u0026gt;Hello Docker!\u0026lt;/h1\u0026gt;\u0026#34;) }) http.ListenAndServe(\u0026#34;:8000\u0026#34;, nil) } Create a Dockerfile # BUILD IMAGE FROM EXISTING IMAGE # Line with \u0026#39;#\u0026#39; will not executed # 1. Call the image # FROM \u0026lt;image name\u0026gt;:\u0026lt;tag\u0026gt; # for the base we will use golang image version 1.15 FROM golang:1.15 # 2. Copy file that needed in this image # COPY \u0026lt;source\u0026gt; \u0026lt;destination\u0026gt; # we will put file main.go in /app/main.go inside the container COPY main.go /app/main.go # 3. Telling the image how to run the app # CMD [\u0026lt;add command using array\u0026gt;] CMD [\u0026#34;go\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;/app/main.go\u0026#34;] # same with \u0026#34;go run /app/main.go\u0026#34; Build Image we can use 3 way to build an image:\nsimple way docker build \u0026amp;lt;path-to-dockerfile\u0026amp;gt;\nadd a name in our image docker build --tag \u0026amp;lt;app name\u0026amp;gt; \u0026amp;lt;path-to-dockerfile\u0026amp;gt;\nadd name and version number docker build --tag \u0026amp;lt;app name\u0026amp;gt;:\u0026amp;lt;version number\u0026amp;gt; \u0026amp;lt;path-to-dockerfile\u0026amp;gt;\n$ docker build --tag app-golang:1.0 . building an image using Dockerfile can be done in various ways, depends on your needs, and many Dockerfile syntaxes are often used when creating an image, such as:\nENTRYPOINT\nRUN\nWORKDIR\nENV\nread this docker documentation, get to know all the syntax, and see the best practice of using it.\nCreate our app container Let’s try to create a container for our app and run it. Then we can check our app using the browser.\nUpload Image to Registry Preparation\nLogin to your account at https://hub.docker.com/ Create New repository for the image Push image\nWe will use the docker command to push the image, docker push \u0026amp;lt;repository name\u0026amp;gt;:\u0026amp;lt;tag\u0026amp;gt;\nIf we try to insert the command, we will get an error: An image does not **exist locally ...**\nThis will happen because we create an image with a name that is different from our repository name. Let’s check the Image in our local, using:\n$ docker images our local image is named app-golang but the docker registry wants repoerna/example-go-app.\nTo resolve this, we need to do create the image with different names by using\n$ docker tag \u0026lt;local-image\u0026gt;:\u0026lt;tagname\u0026gt; \u0026lt;reponame\u0026gt;:\u0026lt;tagname\u0026gt; check docker images in our local, we will see the new image created,\nafter that, we can push to the repository, by using the same command we used before\nOops! We still get an error, our request to push is denied. It is because, our local docker didn’t know, where to push the image.\nWe need to login, by using\n$ docker login input your account credential for the docker hub\nafter we logged in, let\u0026rsquo;s try to push again\nAlright! We success push our local image to the remote repository, lets check in the docker hub\n​ For details about the docker repository, you can read the documentation\nHandle Image with Environment Variable An environment variable is a dynamic-named value that can affect the way running processes will behave on a computer. They are part of the environment in which a process runs. — Wikipedia\nAn environment variable is rarely used directly. It is usually used by a program to configure itself. In software development, some configurations for the program/ application are set by using an environment variable. If we want our program to change some configuration, we can achieve this by changing the environment variable without changing the code.\nin Linux or macOS, you can see your OS environment variable using the command\n$ printenv if you using Windows, you can access the environment variable by open Control Panel \u0026gt; Advanced system settings \u0026gt; Environment Variable. You will see the Environment Variable window.\nIf we want to dockerize our program that needs an environment variable, we should add some commands before running the container. To give you an example, let’s update our program to handle some environment variables. We will add a new route to manage the environment variable.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) func main() { package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) func main() { // * this will set env variable MYNAME // os.Setenv(\u0026#34;MYNAME\u0026#34;, \u0026#34;REPOERNA\u0026#34;) // * get env variable MYNAME appPort := os.Getenv(\u0026#34;APP_PORT\u0026#34;) port := fmt.Sprintf(\u0026#34;:%s\u0026#34;, appPort) myName := os.Getenv(\u0026#34;MYNAME\u0026#34;) txt := fmt.Sprintf(\u0026#34;\u0026lt;h1\u0026gt;Hello, %s\u0026lt;/h1\u0026gt;\u0026#34;, myName) // \u0026lt;-- env var MYNAME will be used in this line // * Handle Route \u0026#34;/\u0026#34; http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;\u0026lt;h1\u0026gt;Hello Docker!\u0026lt;/h1\u0026gt;\u0026#34;) }) // * Handle route \u0026#34;/myname\u0026#34; http.HandleFunc(\u0026#34;/myname\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, txt) }) http.ListenAndServe(port, nil) // \u0026lt;-- env var APP_PORT will be used in this line } Remember, in our program, we need two environment variables, APP_PORT and MYNAME. After updating our program, rebuild it without changing the Dockerfile.\n$ docker build --tag app-golang:1.0 . and then create a container using the image, and add -eto add an environment variable\n$ docker container create --name golang-test-env -p 8080:8080 -e APP_PORT=8080 -e MYNAME=REPOERNA app-golang:1.0 after the container is created, let’s inspect the environment variable in it by using the command\n$ docker container inspect golang-test-env In the list, you will see in Env with APP_PORT and MYNAME. The value is the same as the command that we type before. For PATH, GOLANG_VERSION, GOPATH are automatically added, because we use golang in our Dockerfile.\nSo let\u0026rsquo;s run the container, to check our program is working\n$ docker container start golang-test-env if no error occurred, open in browser localhost:8080/myname, it will show the MYNAME environment variable value.\nNote: when using a Dockerfile to create an image, you can specify the environment variable inside your Dockerfile. Please see the official documentation on how to implement that. Integrate Container Networking In this section, we will talk about connecting containers to another container. Let say we have a web server that needs to communicate with Postgres for its database and Redis for its caching or session storage.\nSo, we will prepare 3 containers, one for the app, one for Postgres, and one for Redis. Before that, let’s prepare our app. We will be using our previous app and add some code to connect with Postgres and Redis.\nUpdate our app main.go\nWe will add some database connections to our app.\nPackage main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/go-redis/redis\u0026#34; _ \u0026#34;github.com/lib/pq\u0026#34; ) func main() { dbHost := os.Getenv(\u0026#34;DB_HOST\u0026#34;) dbPort := 5432 dbUser := \u0026#34;postgres\u0026#34; dbPass := \u0026#34;Secure123\u0026#34; dbName := \u0026#34;docker-demo\u0026#34; redisHost := os.Getenv(\u0026#34;REDIS_HOST\u0026#34;) redisAddr := fmt.Sprintf(\u0026#34;%s:6379\u0026#34;, redisHost) redisPass := \u0026#34;\u0026#34; //no password set redisDB := 0 //default db // * setup postgre connection dsn := fmt.Sprintf(\u0026#34;host=%s port=%d user=%s \u0026#34;+ \u0026#34;password=%s dbname=%s sslmode=disable\u0026#34;, dbHost, dbPort, dbUser, dbPass, dbName) db, err := sql.Open( \u0026#34;postgres\u0026#34;, dsn, ) if err != nil { fmt.Println(err) } // * Ping for test the connection if err = db.Ping(); err != nil { fmt.Println(err) } else { fmt.Println(\u0026#34;DB Postgres Connected !\u0026#34;) } // * setup redis connection rdb := redis.NewClient(\u0026amp;redis.Options{ Addr: redisAddr, Password: redisPass, DB: redisDB, }) // * Ping for test the connection pong, err := rdb.Ping().Result() if err != nil { fmt.Println(err) } else { fmt.Println(pong) fmt.Println(\u0026#34;Redis Connected !\u0026#34;) } // * get env variable MYshNAME appPort := os.Getenv(\u0026#34;APP_PORT\u0026#34;) // handle for default port if appPort == \u0026#34;\u0026#34; { appPort = \u0026#34;8080\u0026#34; } port := fmt.Sprintf(\u0026#34;:%s\u0026#34;, appPort) // myName := os.Getenv(\u0026#34;MYNAME\u0026#34;) // txt := fmt.Sprintf(\u0026#34;\u0026lt;h1\u0026gt;Hello, %s\u0026lt;/h1\u0026gt;\u0026#34;, myName) // * Handle Route \u0026#34;/\u0026#34; http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;\u0026lt;h1\u0026gt;Hello Docker!\u0026lt;/h1\u0026gt;\u0026#34;) }) // * Handle route \u0026#34;/myname\u0026#34; // http.HandleFunc(\u0026#34;/myname\u0026#34;, func(w http.ResponseWriter, r *http.Request) { // fmt.Fprintf(w, txt) // }) http.ListenAndServe(port, nil) } For Postgres and Redis hostname, we will use an environment variable, and because we are using Redis, we need to use modules in our go app. Therefore we need to update our Dockerfile to handle go modules.\nDockerfile\nFROM golang:1.15 ENV GO111MODULE=on WORKDIR /app RUN go mod init COPY . . RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build EXPOSE 8080 CMD [\u0026#34;go\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;/app/main.go\u0026#34;] After the app is ready, we will continue preparing the container, and don’t forget to clean up the previous container\nCreate Container Rebuild our golang app image $ docker build — tag app-golang:1.0 . Create golang app container $ docker container create — name golang-docker -e REDIS_HOST=localhost -e DB_HOST=localhost -p 8080:8080 app-golang:1.0 Create Postgres container $ docker container create --name postgres-docker -p 5432:5432 -e POSTGRES_DB=docker-demo -e POSTGRES_PASSWORD=mysecretpassword postgres Create Redis container $ docker container create --name redis-docker -p 6379:6379 redis let’s see our created containers\nStart Containers start all 3 containers\n$ docker container start redis-docker postgres-docker golang-docker check our app container\n$ docker container logs golang-docker As I expected, an error will happen because we were trying to connect to localhost. We can’t connect to localhost because Redis and Postgres are in a different containers. We need to use the container name as the hostname. So, let’s delete golang-dockercontainer and re-create it.\n$ docker container create --name golang-docker -e REDIS_HOST=redis-docker -e DB_HOST=postgres-docker -p 8080:8080 app-golang:1.0 Start the container, and check logs again.\nWe still can’t connect to Redis and Postgres. What happens here? As you can see, there is an error occur in our app. This will occurred because our program still can’t find Redis and Postgres. Before using localhost or 127.0.0.1 as the host, localhost refers to the hostname in the current computer or system.\nAs you know, when creating a container, the system inside it will be isolated from another container. Even if we want the container to connect to our laptop or computer, we need to expose the container port and mapping it to our computer port. But, after we changed the hostname to the container name, errors still occurred. So how to make containers communicate with each other?\nSetup Container Network To achieve that, we need to use docker network, which will help us connecting containers\n$ docker network --help Create docker network $ docker network create example-network we can check our created network by using\n$ docker network ls Set container network $ docker network connect example-network golang-docker $ docker network connect example-network redis-docker $ docker network connect example-network postgres-docker After we connect the containers to the network, let\u0026rsquo;s inspect our container\n$ docker container inspect golang-docker You can see in \u0026ldquo;Networks\u0026rdquo;, there is example-network, that we created before.\nLet\u0026rsquo;s restart our golang-app container, and check the logs\n$ docker container restart golang-docker Finally, it\u0026rsquo;s connected! Congratulations to us!\nManage Data in Docker When creating an application, it is best to make it stateless. It means no data are saved or the data stored somewhere else. However, some applications need to be stateful, for example, databases. How do we run a stateful application? How can we save the data so when we delete a container, the data will still remain?\nActually, you can read the documentation about that here\nThere are many ways to manage data in Docker. Usually, I will use bind mounts, but we will try to use volume this time.\nIn this example, we will try to create a MongoDB container. To manage data, first, we must know where is application save its data. If you use mongo image from docker hub, we can see in the description at subtitle Where to store data, from there we can see where is mongo data reside, it’s in /data/db.\nSo, let’s start…\nPull image $ docker pull mongo Create new volume $ docker create volume mongo-test The volume will be used in our container. This is where data will be saved. You can check where is volume stored in your computer by using the command:\n$ docker volume inspect \u0026lt;volume-name\u0026gt; Create container $ docker container create --name mongo-docker -v mongo-test:/data/db -p 27017:27017 In this command we use -v \u0026amp;lt;docker_volume\u0026amp;gt;:\u0026amp;lt;data location in application\u0026amp;gt; to create volume binding between docker and our computer.\nStart container $ docker container start mongo-docker Open mongo DB using mongo client, here I’m using Studio 3T By default, there are 3 DB like above in the newly created MongoDB. Let’s create a new DB and add new data in there\nCreate a new DB and insert some data Here, I already create new DB named test_db, a collection name test_collection, and inside that collection there 1 document\nStop and delete the container $ docker container stop mongo-docker $ docker container rm mongo-docker Create and start the container again using the same command in steps 3 and 4\nCheck DB again using Mongo client\nYou will see, that your data is still there. Congratulation!\nThat is one method of how to manage data in docker, there is still many ways to manage data in docker. Please be sure to read the documentation. In there you will know what method to use and how to use it for your needs.\nDocker Compose We already learn to integrate our containers. In the previous example, we use 3 containers, but what if our application or system needs more than that? Doing it manually every step will be a problem, right? So, Docker Compose will help us automate that process.\nBasically, there are 3 steps to use Docker Compose, these steps are:\nDefine your app’s environment with a Dockerfile so it can be reproduced anywhere.\nDefine the services that make up your app in docker-compose.yml to be run together in an isolated environment.\nRun docker-compose up and Compose starts and runs your entire app.\nIn step 1, we already learn how to create Dockerfile so we will focus on step 2, how to create docker-compose.yml file, and step 3, how to run it.\nLet\u0026rsquo;s create our**docker-compose.yml** ,\nversion: \u0026#34;3.9\u0026#34; # optional since v1.27.0 services: db: container_name: postgres-comose image: postgres ports: - 5432:5432 networks: - compose-network environment: - POSTGRES_DB=docker-demo - POSTGRES_PASSWORD=mysecretpassword cache: container_name: redis-compose image: redis ports: - 6379:6379 networks: - compose-network app: container_name: golang-compose # image: app-golang:1.0 build: context: . dockerfile: Dockerfile ports: - 8080:8080 restart: unless-stopped networks: - compose-network depends_on: - db - cache environment: - REDIS_HOST=redis-compose - DB_HOST=postgres-compose - MYNAME=REPOERNA networks: compose-network: name: new-example-network *Note: in the app service environment, we use REDIS_HOST and DB_HOST using Redis and Postgres container name\nOkay, I will explain what we write. At the root of the file, we have:\nversion define Compose release. Each release has different features and parameters that we can use. You can read the compatibility matrix of each version here. If you omit the versionby default, it will use version 1.\nservices defined all services in our system. In our example, before we use Postgres, Redis, and golang app, those 3 services will be defined here.\nnetwork define network will be used, if you haven’t created the network, it will be automatically created, and you can create more than one network here.\nInside services, there is the service name; we have DB, cache, and app. On every service, we will define a parameter that will be used on each service. these parameters are:\ncontainer_name defines name services container.\nimage define an image that will be used for creating the container.\nport define port binding to exposed the port inside a container with the environment outside.\nnetworks define a network that will be used by services.\ndepends_on define other services that needed by app services.\nenvironment define environment variable inside the container.\nIn app service, instead of using an image, we will use build to build the image, below build there is context that define the location of Dockerfle that will be used to build the image and dockerfile to define Dockerfile filename.\nTo run Docker Compose, we need to use some commands, you can check in your terminal by using\n$ docker-compose It will show you a list of commands and a short description of its function. You need to know how to use it properly. There are common commands that I frequently used:\ndocker-compose build It will rebuild the image if you are using build instead of image in your docker-compose.yml, if your services using existing images, there will be an error occurred.\ndocker-compose up -d It will create and start containers, it is best to use-d or daemon mode, to run the process in the background.\ndocker-compose down it will stop and remove containers, networks, images, and volumes. Please beware if you using a database in your services, when you use this command, the data will also be removed.\nSo, let\u0026rsquo;s run the Docker Compose\nRebuild the image $ docker-compose build this process will be the same with docker build\nStart services $ docker-compose up -d Check our application Our services are up! No error occurred.\nClean Up $ docker-compose down Docker Tools — Kitematic Docker tool is software that you can use to help you manage Docker using GUI. Docker has its own tools called Docker Desktop, but it is only for Windows and macOS. For Linux, I preferred using Kitematic because it also can run on Windows, macOS. It also has more features than Docker Desktop.\nThe features are:\nCreate, delete, start \u0026amp; stop a container\nView containers logs\nManaging volumes\nAdd environment variables\nCommand-Line Access\nYou can see the details on\nYou can see the details on Kitematic website or docker documentation.\nDocker Cheat Sheet Refrence [1] What Is Dockerfile: Everything You Need to Know\n[2] Docker Containers and Container Cloud Services\n[3] Basic about Docker in the Oracle\n","permalink":"https://repoerna.github.io/posts/docker-tutorial-complete-beginners-guide/","summary":"Prelude This post will give a basic tutorial on how to using Docker. The topics that will be explained are:\nWhat is Docker\nDocker Architecture\nStart using Docker (Guide to using basic commands)\nCreate Image using Dockerfile\nHandle Image using Environment Variable\nIntegrate Container Networking\nManage Data in Docker\nDocker Compose\nDocker Tools\nDocker Cheat-sheet\nThis post will be pretty long, and I hope you will enjoy it, and feel free to give feedback to help me improve this tutorial.","title":"Docker Tutorial — Complete Beginner’s Guide"}]